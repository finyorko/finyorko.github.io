<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Go语言学习笔记]]></title>
    <url>%2Fgo_learning.html</url>
    <content type="text"><![CDATA[Go语言学习笔记第一个Go程序hello.go ，（Go 语言源文件的扩展是 .go），代码如下： 1234567package mainimport "fmt"func main() &#123; fmt.Println("Hello, World!")&#125; 要执行 Go 语言代码可以使用 go run命令。 执行以上代码输出: 12$ go run hello.go Hello, World! 此外我们还可以使用 go build命令来生成二进制文件： 12345$ go build hello.go $ lshello hello.go$ ./hello Hello, World! Go语言结构GO Hello World 实例 Go 语言的基础组成有以下几个部分： 包声明 引用包 函数 变量 语句&amp;表达式 注释 通过实例来解释： 123456package mainimport "fmt"func main() &#123; /* 这是我的第一个简单的程序 */ fmt.Println("Hello, World!")&#125; 第一行代码 package main定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。 下一行 import &quot;fmt&quot;告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。 下一行 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。 下一行/*...*/是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。 下一行fmt.Println(...)可以将字符串输出到控制台，并在最后自动增加换行字符 \n。使用 fmt.Print(&quot;hello, world\n&quot;)可以得到相同的结果。Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。 当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，如group，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。 执行Go程序 输入命令 go run hello.go 并按回车执行代码 12$ go run hello.goHello, World! 我们还可以使用 go build 命令来生成二进制文件： 12345$ go build hello.go $ lshello hello.go$ ./hello Hello, World! 注意需要注意的是{不能单独放在一行，所以以下代码在运行时会产生错误： 12345678package mainimport "fmt"func main() &#123; // 错误，&#123; 不能在单独的行上 fmt.Println("Hello, World!")&#125; 笔记 当前的调试部分可以使用 go run filename.go 来执行。 可以生成一个 build.sh 脚本，用于在指定位置产生已编译好的 可执文件: 12345678910111213141516#!/usr/bin/env bashCURRENT_DIR=`pwd`OLD_GO_PATH="$GOPATH" #例如: /usr/local/goOLD_GO_BIN="$GOBIN" #例如: /usr/local/go/binexport GOPATH="$CURRENT_DIR" export GOBIN="$CURRENT_DIR/bin"#指定并整理当前的源码路径gofmt -w srcgo install test_helloexport GOPATH="$OLD_GO_PATH"export GOBIN="$OLD_GO_BIN" 关于包，根据本地测试得出以下几点： 文件名与包名没有直接关系，不一定要将文件名与包名定成同一个。 文件夹名与包名没有直接关系，并非需要一致。 同一个文件夹下的文件只能有一个包名，否则编译报错。 文件结构: 123456Test--helloworld.gomyMath--myMath1.go--myMath2.go 测试代码: 12345678910111213// helloworld.gopackage mainimport ("fmt""./myMath")func main()&#123; fmt.Println("Hello World!") fmt.Println(mathClass.Add(1,1)) fmt.Println(mathClass.Sub(1,1))&#125; 12345// myMath1.gopackage mathClassfunc Add(x,y int) int &#123; return x + y&#125; 12345// myMath2.gopackage mathClassfunc Sub(x,y int) int &#123; return x - y&#125; Go语言基础语法Go标记Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成： 1fmt.Println("Hello, World!") 6 个标记是(每行一个)： 123456fmt.Println(&quot;Hello, World!&quot; ) 行分隔符在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。 如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。 以下为两个语句： 12fmt.Println("Hello, World!")fmt.Println("行分隔符，一行一个语句") 注释注释不会被编译，每一个包应该有相关注释。 单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。 多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。 标识符标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(AZ和az)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。 以下是有效的标识符： 12mahesh kumar abc move_name a_123myname50 _temp j a23b9 retVal 以下是无效的标识符： 1ab（以数字开头） case（Go 语言的关键字） a+b（运算符是不允许的） 字符串连接 Go 语言的字符串可以通过+实现： 12345package mainimport "fmt"func main() &#123; fmt.Println("Google" + "Runoob")&#125; 12output:GoogleRunoob 关键字下面列举了 Go 代码中会使用到的 25 个关键字或保留字： break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符： append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr Go 语言的空格Go 语言中变量的声明必须使用空格隔开，如： 1var age int; Go语言数据类型在 Go 编程语言中，数据类型用于声明函数和变量。 数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。 Go 语言按类别有以下几种数据类型： 序号 类型和描述 1 布尔型 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。 2 数字类型 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。 3 字符串类型: 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。 4 派生类型: 包括：(a) 指针类型（Pointer） (b) 数组类型 (c) 结构化类型(struct) (d) Channel 类型 (e) 函数类型 (f) 切片类型 (g) 接口类型（interface） (h) Map 类型 数字类型Go 也有基于架构的类型，例如：int、uint 和 uintptr。 int型 序号 类型和描述 1 uint8 无符号 8 位整型 (0 到 255) 2 uint16 无符号 16 位整型 (0 到 65535) 3 uint32 无符号 32 位整型 (0 到 4294967295) 4 uint64 无符号 64 位整型 (0 到 18446744073709551615) 5 int8 有符号 8 位整型 (-128 到 127) 6 int16 有符号 16 位整型 (-32768 到 32767) 7 int32 有符号 32 位整型 (-2147483648 到 2147483647) 8 int64 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) 浮点型： 序号 类型和描述 1 float32 IEEE-754 32位浮点型数 2 float64 IEEE-754 64位浮点型数 3 complex64 32 位实数和虚数 4 complex128 64 位实数和虚数 其他数字类型 序号 类型和描述 1 byte 类似 uint8 2 rune 类似 int32 3 uint 32 或 64 位 4 int 与 uint 一样大小 5 uintptr 无符号整型，用于存放一个指针 笔记 go 1.9版本对于数字类型，无需定义int及float32、float64，系统会自动识别。 12345678package mainimport "fmt"func main() &#123; var a = 1.5 var b =2 fmt.Println(a,b)&#125; 字符串去除空格和换行符 12345678910111213141516package main import ( "fmt" "strings" ) func main() &#123; str := "这里是 www\n.baidu\n.com" fmt.Println("-------- 原字符串 ----------") fmt.Println(str) // 去除空格 str = strings.Replace(str, " ", "", -1) // 去除换行符 str = strings.Replace(str, "\n", "", -1) fmt.Println("-------- 去除空格与换行后 ----------") fmt.Println(str) &#125; 输出结果为： 123456-------- 原字符串 ----------这里是 www.baidu.com-------- 去除空格与换行后 ----------这里是www.baidu.com Go 语言变量Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。 声明变量的一般形式是使用 var 关键字： 1var identifier type 可以一次声明多个变量： 1var identifier1, identifier2 type 12345678910//实例package mainimport "fmt"func main() &#123; var a string = "Baidu" fmt.Println(a) var b, c int = 1, 2 fmt.Println(b, c)&#125; 123//outputBaidu1 2 变量声明第一种，指定变量类型，如果没有初始化，则变量默认为零值。 12var v_name v_typev_name = value 1234567891011package mainimport "fmt"func main() &#123; // 没有初始化就为零值* var b int fmt.Println(b)//output: 0 // bool 零值为 false* var c bool fmt.Println(c)//output: false&#125; 数值类型（包括complex64/128）为 0 布尔类型为 false 字符串为 “”（空字符串） 以下几种类型为 nil： 123456var a *intvar a []intvar a map[string] intvar a chan intvar a func(string) intvar a error // error 是接口 12345678910111213package mainimport "fmt"func main() &#123; var i int var f float64 var b bool var s string fmt.Printf("%v %v %v %q**\n**", i, f, b, s)&#125; /*output:0 0 false ""*/ 第二种，根据值自行判定变量类型。 1var v_name = value 1234567package mainimport "fmt"func main() &#123; var d = true fmt.Println(d)&#125; //output: true 第三种，省略 var, 注意 *:=* 左侧如果没有声明新的变量，就产生编译错误，格式：v_name := value 12345var intVal int intVal :=1 // 这时候会产生编译错误intVal,intVal1 := 1,2 // 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明 可以将 var f string = &quot;Baidu&quot;简写为 f := &quot;Baidu&quot; 多变量声明1234567891011121314//类型相同多个变量, 非全局变量var vname1, vname2, vname3 typevname1, vname2, vname3 = v1, v2, v3var vname1, vname2, vname3 = v1, v2, v3 // 和 python 很像,不需要显示声明类型，自动推断vname1, vname2, vname3 := v1, v2, v3 // 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误// 这种因式分解关键字的写法一般用于声明全局变量var ( vname1 v_type1 vname2 v_type2) 实例 12345678910111213141516171819202122package mainvar x, y intvar ( // 这种因式分解关键字的写法一般用于声明全局变量 a int b bool)var c, d int = 1, 2var e, f = 123, "hello"//这种不带声明格式的只能在函数体中出现//g, h := 123, "hello"func main()&#123; g, h := 123, "hello" println(x, y, a, b, c, d, e, f, g, h)&#125;/*output:0 0 0 false 1 2 123 hello 123 hello*/]]></content>
      <categories>
        <category>-Go语言</category>
      </categories>
      <tags>
        <tag>-Go语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++剑指offer]]></title>
    <url>%2Foffer_dir.html</url>
    <content type="text"><![CDATA[二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路从左下角元素往上查找，右边元素是比这个元素大，上边是的元素比这个元素小。于是，target比这个元素小就往上找，比这个元素大就往右找。如果出了边界，则说明二维数组中不存在target元素。 代码实现123456789101112131415161718class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; // array是二维数组，这里没做判空操作 int rows = array.size(); int cols = array[0].size(); int i=rows-1,j=0;//左下角元素坐标 while(i&gt;=0 &amp;&amp; j&lt;cols)&#123;//使其不超出数组范围 if(target&lt;array[i][j]) i--;//查找的元素较少，往上找 else if(target&gt;array[i][j]) j++;//查找元素较大，往右找 else return true;//找到 &#125; return false; &#125;&#125;; 替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路从前往后记录空格数目，从后往前替换空格 代码实现1234567891011121314151617181920class Solution &#123;public: void replaceSpace(char *str,int length) &#123; int num = 0 ; for(int i =0;i&lt;length;i++)&#123; if(str[i]==' ')&#123;num++;&#125; &#125; for(int i = length -1 ; i &gt;= 0; i--)&#123; if(str[i] != ' ')&#123; str[i+num*2] = str[i]; &#125; else&#123; str[i+num*2] = '0'; str[i+num*2-1] = '2'; str[i+num*2-2] = '%'; num--; &#125; &#125; &#125;&#125;; 从尾到头打印链表题目描述输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 题目分析比较简单，直接看代码 代码实现 方法一： 链表从尾到头输出，利用递归实现，不使用库函数直接printf输出的时候用递归比较好 123456789101112131415161718192021222324252627/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(struct ListNode* head) &#123; vector&lt;int&gt; value; if(head != NULL) &#123; value.insert(value.begin(),head-&gt;val); if(head-&gt;next != NULL) &#123; vector&lt;int&gt; tempVec = printListFromTailToHead(head-&gt;next); if(tempVec.size()&gt;0) value.insert(value.begin(),tempVec.begin(),tempVec.end()); &#125; &#125; return value; &#125;&#125;; 用库函数，每次扫描一个节点，将该结点数据存入vector中，如果该节点有下一节点，将下一节点数据直接插入vector最前面，直至遍历完，或者直接加在最后，最后调用reverse 。[头插vector 效率太低，可以先vector.push_back返回之前翻转vector，std::reverse(begin,end) ] 123456789101112131415161718192021222324252627/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(struct ListNode* head) &#123; vector&lt;int&gt; value; if(head != NULL) &#123; value.insert(value.begin(),head-&gt;val); while(head-&gt;next != NULL) &#123; value.insert(value.begin(),head-&gt;next-&gt;val); head = head-&gt;next; &#125; &#125; return value; &#125;&#125;; 重建二叉树题目分析前序加中序序列，分解过程图示如下（王道数据结构P120） 由先序序列第一个pre[0]在中序序列中找到根节点位置gen 以gen为中心遍历 0~gen左子树 子中序序列：0~gen-1，放入vin_left[] 子先序序列：1~gen放入pre_left[]，+1可以看图，因为头部有根节点 gen+1~vinlen为右子树 子中序序列：gen+1 ~ vinlen-1放入vin_right[] 子先序序列：gen+1 ~ vinlen-1放入pre_right[] 由先序序列pre[0]创建根节点 连接左子树，按照左子树子序列递归（pre_left[]和vin_left[]） 连接右子树，按照右子树子序列递归（pre_right[]和vin_right[]） 返回根节点 代码实现1234567Definition for binary treestruct TreeNode &#123;int val;TreeNode *left;TreeNode *right;TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;; 方法一 123456789101112131415161718192021222324252627282930313233343536373839*/class Solution &#123;public: struct TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre, vector&lt;int&gt; in) &#123; int inlen = in.size(); if (inlen == 0) return NULL; vector&lt;int&gt; left_pre, right_pre, left_in, right_in; //创建根节点，根节点肯定是前序遍历的第一个数 TreeNode* head = new TreeNode(pre[0]); //找到中序遍历根节点所在位置,存放于变量gen中 int gen = 0; for (int i = 0; i&lt;inlen; i++) &#123; if (in[i] == pre[0]) &#123; gen = i; break; &#125; &#125; //对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边 //利用上述这点，对二叉树节点进行归并 for (int i = 0; i&lt;gen; i++) &#123; left_in.push_back(in[i]); left_pre.push_back(pre[i + 1]);//前序第一个为根节点 &#125; for (int i = gen + 1; i&lt;inlen; i++) &#123; right_in.push_back(in[i]); right_pre.push_back(pre[i]); &#125; //和shell排序的思想类似，取出前序和中序遍历根节点左边和右边的子树 //递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点 head-&gt;left = reConstructBinaryTree(left_pre, left_in); head-&gt;right = reConstructBinaryTree(right_pre, right_in); return head; &#125;&#125;; 方法二（厉害） $i_{0}$=startIn . . . . . i startPre . . . . . x $x=startPre+i-startIn$ 123456789101112131415161718 public TreeNode reConstructBinaryTree( int [] pre, int [] in) &#123; TreeNode root=reConstructBinaryTree(pre, 0 ,pre.length- 1 ,in, 0 ,in.length- 1 ); return root; &#125; //前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125; private TreeNode reConstructBinaryTree( int [] pre, int startPre, int endPre, int [] in, int startIn, int endIn) &#123; if (startPre&gt;endPre||startIn&gt;endIn) return null ; TreeNode root= new TreeNode(pre[startPre]); for ( int i=startIn;i&lt;=endIn;i++) if (in[i]==pre[startPre])&#123; root.left=reConstructBinaryTree(pre,startPre+ 1 ,startPre+i-startIn,in,startIn,i- 1 ); root.right=reConstructBinaryTree(pre,i-startIn+startPre+ 1 ,endPre,in,i+ 1 ,endIn); break ; &#125; return root; &#125;&#125; 用两个栈实现队列题目分析：入队：将元素进栈A 出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。 代码实现12345678910111213141516171819202122232425262728class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; int a; if (stack2.empty()) &#123; while (!stack1.empty()) &#123; a = stack1.top(); stack2.push(a); stack1.pop(); &#125; &#125; a = stack2.top(); stack2.pop(); return a; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; 拓展如果用两个队列实现一个栈的功能? 解题思路： 入栈：将元素进队列A 出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素 以此出队列并放入队列B，直到队列A中的元素留下一个，然后队列A出队列，再把 队列B中的元素出队列以此放入队列A中。 旋转数组的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 题目分析采用二分法解答这个问题： mid = low + (high - low)/2 需要考虑三种情况： (1)array[mid] &gt; array[high]: 出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 low = mid + 1 (2)array[mid] == array[high]: 出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 ， high = high - 1 (3)array[mid] &lt; array[high]: 出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左边。因为右边必然都是递增的。 high = mid 注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid 一定会指向下标靠前的数字 比如 array = [4,6] array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ; 如果high = mid - 1，就会产生错误， 因此high = mid 但情形(1)中low = mid + 1就不会错误 代码实现1234567891011121314151617class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; array) &#123;int low = 0 ; int high = array.size() - 1; while(low &lt; high)&#123; int mid = low + (high - low) / 2; if(array[mid] &gt; array[high])&#123; low = mid + 1; &#125;else if(array[mid] == array[high])&#123; high = high - 1; &#125;else&#123; high = mid; &#125; &#125; return array[low]; &#125;&#125;; 斐波那契数列题目描述大家都知道斐波那契数列$ \begin{equation} f(x)= \begin{cases} 1&amp; \text{x=1;} \ 1&amp; \text{x=2;} \ 1&amp; \text{$f(n-1)+f(n)$} \end{cases} \end{equation} $，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 n&lt;=39 题目分析分别用f和g表示$f(n)$和$f(n+1)$,用循环来实现，最好不要用递归，递归重复计算的部分太多了，花费太大 。 代码实现1234567891011class Solution &#123;public: int Fibonacci(int n) &#123; int f = 0, g = 1; while(n--) &#123; g += f; f = g - f; &#125; return f; &#125;&#125;; 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 题目分析对于本题,前提只有 一次 1阶或者2阶的跳法。 a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1); b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2) c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2) d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2 e.可以发现最终得出的是一个斐波那契数列： $ \begin{equation} f(x)= \begin{cases} 1&amp; \text{x=1;} \ 1&amp; \text{x=2;} \ 1&amp; \text{$f(n-1)+f(n)$} \end{cases} \end{equation} $ 代码实现123456789101112131415161718192021class Solution &#123;public: int jumpFloor(int number) &#123; if (number &lt;= 0) &#123; return 0; &#125; if (number == 1) &#123; return 1; &#125; if (number == 2) &#123; return 2; &#125; int first = 1, second = 2, third = 0; for (int i = 3; i &lt;= number; i++) &#123; third = first + second; first = second; second = third; &#125; return third; &#125;&#125;; 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 题目分析-1 关于本题，前提是n个台阶会有一次n阶的跳法。分析如下: f(1) = 1 f(2) = f(2-1) + f(2-2) //f(2-2) 表示2阶一次跳2阶的次数。 f(3) = f(3-1) + f(3-2) + f(3-3) … f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) 说明： 1）这里的f(n) 代表的是n个台阶有一次1,2,…n阶的 跳法数。 2）n = 1时，只有1种跳法，f(1) = 1 3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ， ​ f(2) = f(2-1) + f(2-2) 4) n = 3时，会有三种跳得方式，1阶、2阶、3阶， 那么就是第一次跳出1阶后面 剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) 因此结论是f(3) = f(3-1)+f(3-2)+f(3-3) 5) n = n时，会有n中跳的方式，1阶、2阶…n阶，得出结论： ​ f(n) = f(n-1)+f(n-2)+…+f(n-(n-1)) + f(n-n) =&gt; f(0) + f(1) + f(2) + f(3) + … + f(n-1) 6) 由以上已经是一种结论，但是为了简单，我们可以继续简化： f(n-1) = f(0) + f(1)+f(2)+f(3) + … + f((n-1)-1) = f(0) + f(1) + f(2) + f(3) + … + f(n-2) f(n) = f(0) + f(1) + f(2) + f(3) + … + f(n-2) + f(n-1) = f(n-1) + f(n-1) 可以得出： f(n) = 2*f(n-1) 7) 得出最终结论,在n阶台阶，一次有1、2、…n阶的跳的方式时，总得跳法为： ​ $ \begin{equation} f(x)= \begin{cases} 1&amp; \text{n=0;} \ 1&amp; \text{n=1;} \ 2*f(n-1)&amp; \text{$n&gt;=2$} \end{cases} \end{equation} $ 代码实现- 11234567891011121314151617181920public class Solution &#123; public int JumpFloorII(int target) &#123; if (target &lt;= 0) &#123; return -1; &#125; else if (target == 1) &#123; return 1; &#125; else &#123; return 2 * JumpFloorII(target - 1); &#125; &#125;&#125;//也可以用移位运算符/*class Solution &#123;public: int jumpFloorII(int number) &#123; int a=1; return a&lt;&lt;(number-1); &#125;&#125;;*/ 题目分析-2（概率内容或者基础排列组合？？有点分不清了）假设有n（n&gt;=2）个台阶，因为青蛙可以一步跳任意阶，所以第n层台阶一定会被青蛙踩到，剩下的就看第1~n-1层台阶会不会被踩到，每层台阶可以任意选择会不会被踩到，所以有$2^{n-1}$种情况 代码实现1234567891011class Solution &#123;public: int jumpFloorII(int number) &#123; int j=1; while(--number) &#123; j*=2; &#125; return j; &#125;&#125;; 矩形覆盖题目描述我们可以用2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 题目分析依旧是斐波那契数列 n&lt;=0时，直接return 1； n=1时，只有一种摆放方法，return 1； n=2时，有两种摆放方法，return 2； n&gt;=2时，分为两步考虑， 第一次摆放2*1的小矩阵，则 摆放方法总共为f(target - 1) $\checkmark$ $\checkmark$ 第一次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2) 因为，摆放了一块1*2的小矩阵（用√√表示），对应下方的1*2（用××表示）摆放方法就确定了，所以为f(targte-2) $\checkmark$ $\checkmark$ $\times$ $\times$ 代码实现123456789101112class Solution &#123;public: int rectCover(int number) &#123; if ( number &lt; 1 ) return 0; int g = 1, f = 2; while ( --number ) &#123; f = f + g; g = f - g; &#125; return g; &#125;&#125;; 二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 题目分析-1用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数 代码实现-112345678910111213class Solution &#123;public: int NumberOf1(int n) &#123; int count = 0; int flag = 1; while (flag != 0) &#123; if ((n &amp; flag) != 0) count++; flag = flag &lt;&lt; 1; &#125; &#125;&#125;; 题目分析-2使用(n - 1) &amp; n， 把最右边的一个1变成0 代码实现-2123456789101112class Solution &#123;public: int NumberOf1(int n) &#123; int count = 0; while (n != 0) &#123; ++count; n = (n - 1) &amp; n; &#125; return count; &#125;&#125;; 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 保证base和exponent不同时为0 题目分析简单快速幂 举例分析：13=1101 $base^{1101}$=$base^{0001}$*$base^{0100}$*$base^{1000}$ 通过&amp;1和&gt;&gt;1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果 代码实现12345678910111213class Solution &#123;public: double Power(double base, int exponent) &#123; long long p = abs((long long)exponent); double r = 1.0; while(p)&#123; if(p &amp; 1) r *= base; base *= base; p &gt;&gt;= 1; &#125; return exponent &lt; 0 ? 1/ r : r; &#125;&#125;;]]></content>
      <categories>
        <category>-算法</category>
      </categories>
      <tags>
        <tag>-算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2Fsort.html</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。 12345678910void bubble_sort(int arr[], int len) &#123; int i, j, temp; for (i = 0; i &lt; len - 1; i++) for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125;&#125; 选择排序选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 12345678910111213141516171819void swap(int *a,int *b) //交換兩個變數&#123; int temp = *a; *a = *b; *b = temp;&#125;void selection_sort(int arr[], int len) &#123; int i,j; for (i = 0 ; i &lt; len - 1 ; i++) &#123; int min = i; for (j = i + 1; j &lt; len; j++) //走訪未排序的元素 if (arr[j] &lt; arr[min]) //找到目前最小值 min = j; //紀錄最小值 swap(&amp;arr[min], &amp;arr[i]); //做交換 &#125;&#125; 插入排序插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 123456789void insertion_sort(int arr[], int len)&#123; int i,j,temp; for (i=1;i&lt;len;i++)&#123; temp = arr[i]; for (j=i;j&gt;0 &amp;&amp; arr[j-1]&gt;temp;j--) arr[j] = arr[j-1]; arr[j] = temp; &#125;&#125; 归并排序归并排序使用到了分治的思想, 将一个数组分为两部分, 并分别将两部分排序完成, 而后只用对两个排序好的子序列进行合并即可. 对两个子序列的合并操作也使用相同的策略, 递归的进行. 在进行合并的时候, 需要将原来的数组排序结果保存到另一个数组中, 空间复杂度为$O(n)$. 归并排序时间复杂度为$O(nlog(n))$. 典型应用为求逆序对数. 迭代法1234567891011121314151617181920212223242526272829303132int min(int x, int y) &#123; return x &lt; y ? x : y;&#125;void merge_sort(int arr[], int len) &#123; int* a = arr; int* b = (int*) malloc(len * sizeof(int)); int seg, start; for (seg = 1; seg &lt; len; seg += seg) &#123; for (start = 0; start &lt; len; start += seg + seg) &#123; int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len); int k = low; int start1 = low, end1 = mid; int start2 = mid, end2 = high; while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++]; while (start1 &lt; end1) b[k++] = a[start1++]; while (start2 &lt; end2) b[k++] = a[start2++]; &#125; int* temp = a; a = b; b = temp; &#125; if (a != arr) &#123; int i; for (i = 0; i &lt; len; i++) b[i] = a[i]; b = a; &#125; free(b);&#125; 递归法12345678910111213141516171819202122void merge_sort_recursive(int arr[], int reg[], int start, int end) &#123; if (start &gt;= end) return; int len = end - start, mid = (len &gt;&gt; 1) + start; int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; merge_sort_recursive(arr, reg, start1, end1); merge_sort_recursive(arr, reg, start2, end2); int k = start; while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++]; while (start1 &lt;= end1) reg[k++] = arr[start1++]; while (start2 &lt;= end2) reg[k++] = arr[start2++]; for (k = start; k &lt;= end; k++) arr[k] = reg[k];&#125;void merge_sort(int arr[], const int len) &#123; int reg[len]; merge_sort_recursive(arr, reg, 0, len - 1);&#125; 快速排序迭代法12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct _Range &#123; int start, end;&#125; Range;Range new_Range(int s, int e) &#123; Range r; r.start = s; r.end = e; return r;&#125;void swap(int *x, int *y) &#123; int t = *x; *x = *y; *y = t;&#125;void quick_sort(int arr[], const int len) &#123; if (len &lt;= 0) return; // 避免len等于负值引发段错误（Segment Fault） // r[]列表,p数量,r[p++]为push,r[--p]为pop且取得元素 Range r[len]; int p = 0; r[p++] = new_Range(0, len - 1); while (p) &#123; Range range = r[--p]; if (range.start &gt;= range.end) continue; int mid = arr[(range.start + range.end) / 2]; //选择中间点为基准点 int left = range.start, right = range.end; do &#123; while (arr[left] &lt; mid) ++left; // 检测基准点左侧是否符合要求 while (arr[right] &gt; mid) --right; //检测基准点右侧是否符合要求 if (left &lt;= right) &#123; swap(&amp;arr[left],&amp;arr[right]); left++;right--; //移动指针以继续 &#125; &#125; while (left &lt;= right); if (range.start &lt; right) r[p++] = new_Range(range.start, right); if (range.end &gt; left) r[p++] = new_Range(left, range.end); &#125;&#125; 递归法左右指针法123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;void swap(int *x, int *y) &#123; int t = *x; *x = *y; *y = t;&#125;void quick_sort_recursive(int arr[], int left, int right) &#123; if (left &gt;= right) return; int mid = arr[right]; int begin = left, end = right - 1;//左右指针法 while (begin &lt; end) &#123; while (arr[begin] &lt; mid &amp;&amp; begin &lt; end) begin++; while (arr[end] &gt;= mid &amp;&amp; begin &lt; end) end--; swap(&amp;arr[begin], &amp;arr[end]); &#125; if (arr[begin] &gt;= arr[right]) swap(&amp;arr[begin], &amp;arr[right]); else begin++; if (begin) quick_sort_recursive(arr, left, begin - 1); quick_sort_recursive(arr, begin + 1, right);&#125;void quick_sort(int arr[], int len) &#123; quick_sort_recursive(arr, 0, len - 1);&#125;int main()&#123; int a[10] = &#123; 8,7,5,10,3,1,2,4,9,6 &#125;; quick_sort(a, 10); for(int i=0;i&lt;10;i++) cout &lt;&lt; a[i]; return 0;&#125; 挖洞法123456789101112131415161718192021222324void quick_sort(T a[], int start, int end)&#123; if(end-start &lt; 1) return; if(end-start == 1) &#123; if(a[start]&gt;a[end]) swap(a[start], a[end]); return; &#125; int key = a[start], i=start, j=end; while (i&lt;j) &#123; while(i&lt;j &amp;&amp; key &lt; a[j]) j--; a[i] = a[j]; while(i&lt;j &amp;&amp; key &gt; a[i]) i++; a[j] = a[i]; &#125; a[i] = key; quick_sort(a, start, i-1); quick_sort(a, i+1, end);&#125; 例：找出第k大或者第k小的数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133//目前还有错误，还待解决中。。。//大到小排序1 2 3 4 5 6 7 8 9 10 第五大会出现错误，思路好的时候整理#include&lt;iostream&gt;using namespace std;//从小到大排序int partion1(int A[], int low, int high)&#123; int pivot = A[low];//用第一个数作为主元 while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &gt;= pivot) --high; A[low] = A[high]; while (low &lt; high&amp;&amp;A[low] &lt;= pivot) ++low; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125;//修改大于小于号后，从大到小排序int partion2(int A[], int low, int high)&#123; int pivot = A[low];//用第一个数作为主元 while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &lt;= pivot) --high; A[low] = A[high]; while (low &lt; high&amp;&amp;A[low] &gt;= pivot) ++low; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125;//调用从小到大排序的分割法，来找出第K小的数int find_k_small(int A[], int low, int high, int k)&#123; if (low &lt; high) &#123; int pivot_pos = partion1(A, low, high); if (pivot_pos + 1 == k) return A[pivot_pos]; else if (pivot_pos + 1 &gt; k) find_k_small(A, low, pivot_pos - 1, k); else find_k_small(A, pivot_pos + 1, high, k); &#125; else return -1;&#125;//找出第K大的数int find_k_big(int A[], int low, int high, int k)&#123; if (low &lt; high) &#123; int pivot_pos = partion2(A, low, high); if (pivot_pos + 1 == k) return A[pivot_pos]; else if (pivot_pos + 1 &gt; k) return find_k_big(A, low, pivot_pos - 1, k); else return find_k_big(A, pivot_pos + 1, high, k); &#125; else return -1;&#125;void quick_sort1(int A[], int low, int high)&#123; if (low &lt; high) &#123; int pivot_pos = partion1(A, low, high); quick_sort1(A, low, pivot_pos - 1); quick_sort1(A, pivot_pos + 1, high); &#125;&#125;void quick_sort2(int A[], int low, int high)&#123; if (low &lt; high) &#123; int pivot_pos = partion2(A, low, high); quick_sort2(A, low, pivot_pos - 1); quick_sort2(A, pivot_pos + 1, high); &#125;&#125;int main()&#123; int n; cout &lt;&lt; &quot;输入元素个数： &quot;; cin &gt;&gt; n; int *A = new int[n]; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; A[i]; int k; cout &lt;&lt; &quot;输入要找出第几小的数： &quot; &lt;&lt; endl; cin &gt;&gt; k; cout &lt;&lt; &quot;找出第&quot; &lt;&lt; k &lt;&lt; &quot;小的数:&quot; &lt;&lt; endl; int ans = find_k_small(A, 0, n - 1, k); cout &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; &quot;排序后的结果：&quot; &lt;&lt; endl; quick_sort1(A, 0, n - 1); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; A[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; int k2; cout &lt;&lt; &quot;输入要找出第几大的数： &quot; &lt;&lt; endl; cin &gt;&gt; k2; cout &lt;&lt; &quot;找出第&quot; &lt;&lt; k2 &lt;&lt; &quot;大的数:&quot; &lt;&lt; endl; ans = find_k_big(A, 0, n - 1, k2); cout &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; &quot;排序后的结果：&quot; &lt;&lt; endl; quick_sort2(A, 0, n - 1); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; A[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; delete[] A; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new和malloc内部实现的区别]]></title>
    <url>%2Fnew%26malloc.html</url>
    <content type="text"><![CDATA[new 和 malloc 内部的实现方式有什么区别？new 的功能是在堆区新建一个对象，并返回该对象的指针。 所谓的【新建对象】的意思就是，将调用该类的构造函数，因为如果不构造的话，就不能称之为一个对象。 而 malloc 只是机械的分配一块内存，如果用 mallco 在堆区创建一个对象的话，是不会调用构造函数的。 严格说来用 malloc 不能算是新建了一个对象，只能说是分配了一块与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，按这个逻辑来，也不存在构造函数什么事。 同样的，用 delete 去释放一个堆区的对象，会调用该对象的析构函数。 用 free 去释放一个堆区的对象，不会调用该对象的析构函数。 做个简单的实验即可明了: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;malloc.h&gt;class TEST&#123;private: int num1; int num2;public: TEST() &#123; num1 = 10; num2 = 20; &#125; void Print() &#123; std::cout &lt;&lt; num1 &lt;&lt; " " &lt;&lt; num2 &lt;&lt; std::endl; &#125;&#125;;int main(void)&#123; // 用malloc()函数在堆区分配一块内存空间，然后用强制类型转换将该块内存空间 // 解释为是一个TEST类对象，这不会调用TEST的默认构造函数 TEST * pObj1 = (TEST *)malloc(sizeof(TEST)); pObj1-&gt;Print(); // 用new在堆区创建一个TEST类的对象，这会调用TEST类的默认构造函数 TEST * pObj2 = new TEST; pObj2-&gt;Print(); return 0;&#125;/*运行结果：------------------------------842150451 -842150451 |10 20 |请按任意键继续. . . |-----------------------------我们可以看到pObj1所指的对象中，字段num1与num2都是垃圾值而pObj2所指的对象中，字段num1与num2显然是经过了构造后的值*/]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信防撤回脚本]]></title>
    <url>%2F3.html</url>
    <content type="text"><![CDATA[Windows微信防撤回脚本测试版本：2.6.7.57 ~ 2.6.8.51下载地址：https://pan.baiduwp.com/s/1UBpRXRyd9uXBeqDbc0DKWg 提取码: 6666使用方法：将下载的dll文件，放置在微信的安装目录（WeChat.exe所在目录）下，默认安装目录 （C:\Program Files(x86)\Tencent\WeChat），如果在安装微信时，自定义了微信安装位置，请自 行查找。（如果有问题，右下角蓝色聊天框戳我）测试结果： 组件制作过程使用工具：x32dbg调试器打开微信，并登录；打开x32dbg，文件-附加-选择“微信”，如下图； 符号-搜索关键词：“win”，选择wechatwin.dll模块，然后双击 跳转至“引用”区域 ； 右键搜索-当前模块-字符串，输入搜索关键次“revokemsg”，选择 mov.ecx.wechatwin.xxxxxx 字段结果，双击定位至详情 从定位直至上拉，第一一个je开头行，修改成jmp开头行，点确定]]></content>
      <categories>
        <category>防撤回</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[基于tensorflow的人脸识别系统]]></title>
    <url>%2F4.html</url>
    <content type="text"><![CDATA[环境搭建ubuntu16.04+Anaconda4.2.0+python3.5+opencv2的环境搭建 代码分析检验导包问题的代码12345678910111213141516import tensorflow as tf# 创建一个常量 op, 产生一个 1x2 矩阵. 这个 op 被作为一个节点# 加到默认图中.# 构造器的返回值代表该常量 op 的返回值.##matrix1 = tf.constant([[3., 3.]])# 创建另外一个常量 op, 产生一个 2x1 矩阵.##matrix2 = tf.constant([[2.],[2.]])# 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.# 返回值 'product' 代表矩阵乘法的结果.##product = tf.matmul(matrix1,matrix2)from skimage import io, transformimport globimport osimport time import tensorflow as tfimport numpy as np 将训练集下的图片resize一下，伴随着打开每一个子文件夹，我们要为其设置一个labels，一个文件夹的1000应一个label，共68个abel，这是后面检验acc的唯一指标，即是否能把测试集的照片通过我们的网络输出到指定出口得到正确的label。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189path=''#将所有的图片resize成100*100w=128h=128c=3#读取图片def read_img(path): cate=[path+'/'+x for x in os.listdir(path) if os.path.isdir(path+'/'+x)] imgs=[] labels=[] for idx,folder in enumerate(cate): for im in glob.glob(folder+'/*.png'): print('reading the images:%s'%(im)) img=io.imread(im) img=transform.resize(img,(w,h,c)) imgs.append(img) labels.append(idx) return np.asarray(imgs,np.float32),np.asarray(labels,np.int32) data,label=read_img(path)# 将所有数据分为训练集和验证集ratio = 0.95#训练集占比s = np.int ( num_example * ratio )x_train = data[:s]y_train = label[:s]x_val = data[s:]y_val = label[s:]# -----------------构建网络----------------------# 占位符x = tf.placeholder ( tf.float32, shape=[None, w, h, c], name='x' )y_ = tf.placeholder ( tf.int32, shape=[None, ], name='y_' )def CNNlayer(): # 第一个卷积层（128——&gt;64) conv1 = tf.layers.conv2d ( inputs=x, filters=32, kernel_size=[5, 5], padding="same", activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ) ) pool1 = tf.layers.max_pooling2d ( inputs=conv1, pool_size=[2, 2], strides=2 ) # 第二个卷积层(64-&gt;32) conv2 = tf.layers.conv2d ( inputs=pool1, filters=64, kernel_size=[5, 5], padding="same", activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ) ) pool2 = tf.layers.max_pooling2d ( inputs=conv2, pool_size=[2, 2], strides=2 ) # 第三个卷积层(32-&gt;16) conv3 = tf.layers.conv2d ( inputs=pool2, filters=128, kernel_size=[3, 3], padding="same", activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ) ) pool3 = tf.layers.max_pooling2d ( inputs=conv3, pool_size=[2, 2], strides=2 ) # 第四个卷积层(16-&gt;8) conv4 = tf.layers.conv2d ( inputs=pool3, filters=128, kernel_size=[3, 3], padding="same", activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ) ) pool4 = tf.layers.max_pooling2d ( inputs=conv4, pool_size=[2, 2], strides=2 ) re1 = tf.reshape ( pool4, [-1, 8 * 8 * 128] ) # 全连接层 dense1 = tf.layers.dense ( inputs=re1, units=1024, activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ), kernel_regularizer=tf.contrib.layers.l2_regularizer ( 0.003 ) ) dense2 = tf.layers.dense ( inputs=dense1, units=512, activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ), kernel_regularizer=tf.contrib.layers.l2_regularizer ( 0.003 ) ) logits = tf.layers.dense ( inputs=dense2, units=68, activation=None, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ), kernel_regularizer=tf.contrib.layers.l2_regularizer ( 0.003 ) ) return logits# ----------网络结束---------------------------# 定义一个函数，按批次取数据def minibatches(inputs=None, targets=None, batch_size=None, shuffle=False): assert len ( inputs ) == len ( targets ) if shuffle: indices = np.arange ( len ( inputs ) ) np.random.shuffle ( indices ) for start_idx in range ( 0, len ( inputs ) - batch_size + 1, batch_size ): if shuffle: excerpt = indices[start_idx:start_idx + batch_size] else: excerpt = slice ( start_idx, start_idx + batch_size ) yield inputs[excerpt], targets[excerpt]# 训练和测试数据，可将n_epoch设置更大一些saver = tf.train.Saver ( max_to_keep=3 )max_acc = 0f = open ( 'ckpt1/acc.txt', 'w' )n_epoch = 10batch_size = 64sess = tf.InteractiveSession ( )sess.run ( tf.global_variables_initializer ( ) )for epoch in range ( n_epoch ): start_time = time.time ( ) # training train_loss, train_acc, n_batch = 0, 0, 0 for x_train_a, y_train_a in minibatches ( x_train, y_train, batch_size, shuffle=True ): _, err, ac = sess.run ( [train_op, loss, acc], feed_dict=&#123;x: x_train_a, y_: y_train_a&#125; ) train_loss += err; train_acc += ac; n_batch += 1 print ( " train loss: %f" % (train_loss / n_batch) ) print ( " train acc: %f" % (train_acc / n_batch) ) # validation val_loss, val_acc, n_batch = 0, 0, 0 for x_val_a, y_val_a in minibatches ( x_val, y_val, batch_size, shuffle=False ): err, ac = sess.run ( [loss, acc], feed_dict=&#123;x: x_val_a, y_: y_val_a&#125; ) val_loss += err; val_acc += ac; n_batch += 1 print ( " validation loss: %f" % (val_loss / n_batch) ) print ( " validation acc: %f" % (val_acc / n_batch) ) f.write ( str ( epoch + 1 ) + ', val_acc: ' + str ( val_acc ) + '\n' ) if val_acc &gt; max_acc: max_acc = val_acc saver.save ( sess, 'ckpt1/faces.ckpt', global_step=epoch + 1 )f.close ( )detector = dlib.get_frontal_face_detector ( ) # 获取人脸分类器ID = (1511346,1610731,1610763,1610260,1611407,1611408, 1611409,1611412,1611413,1611415,1611417,1611418, 1611419,1611420,1611421,1611424,1611425,1611426, 1611427,1611430,1611431,1611433,1611434,1611436, 1611437,1611438,1611440,1611444,1611446,1611447, 1611449,1611450,1611451,1511453,1611455,1611458, 1611459,1611460,1611461,1611462,1611470,1611471, 1611472,1611472,1611476,1611478,1611480,1611482, 1611483,1611486,1611487,1611488,1611490,1611491, 1611492,1611493,1611494,1613371,1613376,1613378, 1613550,1711459 )#两个操作是拿到dlib的人脸分类器（相当于dlib的训练代码跑完的结果存下的参数变量结构等东西），然后建个数组当输出和ID的映射#最终交互检验：user = input ( "图片（G）还是摄像头（V）:" )if user == "G": path = input ( "图片路径名是：" ) img = cv2.imread ( path ) dets = detector ( img, 1 ) print ( "Number of faces detected: &#123;&#125;".format ( len ( dets ) ) ) for index, face in enumerate ( dets ): print ( 'face &#123;&#125;; left &#123;&#125;; top &#123;&#125;; right &#123;&#125;; bottom &#123;&#125;'.format ( index, face.left ( ), face.top ( ), face.right ( ), face.bottom ( ) ) ) left = face.left ( ) top = face.top ( ) right = face.right ( ) bottom = face.bottom ( ) cv2.rectangle ( img, (left, top), (right, bottom), (0, 255, 0), 3 ) io.imsave ( 'temp.png', img ) img1 = io.imread ( 'temp.png' ) img1 = transform.resize ( img1, (w, h, c) ) cv2.imshow ( 'image', img1 ) img1 = img[top:bottom, left:right] img1 = transform.resize ( img1, (w, h, c) ) # cv2.imshow('image1',img) res = sess.run ( predict, feed_dict=&#123;x: [img1]&#125; ) print ( ID[res[0]] ) if len ( dets ) == 0: img = transform.resize ( img, (w, h, c) ) res = sess.run ( predict, feed_dict=&#123;x: [img]&#125; ) print ( ID[res[0]] ) cv2.waitKey ( 0 ) cv2.destroyAllWindows ( ) cv2.waitKey ( 0 ) cv2.destroyAllWindows ( )else: # 打开摄像头 cap = cv2.VideoCapture ( 0 ) # 视屏封装格式 while True: ret, frame = cap.read ( ) gray = cv2.cvtColor ( frame, cv2.COLOR_BGR2GRAY ) cv2.imshow ( 'frame', frame ) # 抓取图像，s画人脸框，q结束识别 if cv2.waitKey ( 1 ) &amp; 0xFF == ord ( 's' ): cv2.imwrite ( 'now.png', frame ) img = cv2.imread ( "now.png" ) dets = detector ( img, 1 ) print ( "Number of faces detected: &#123;&#125;".format ( len ( dets ) ) ) for index, face in enumerate ( dets ): print ( 'face &#123;&#125;; left &#123;&#125;; top &#123;&#125;; right &#123;&#125;; bottom &#123;&#125;'.format ( index, face.left ( ), face.top ( ), face.right ( ), face.bottom ( ) ) ) left = face.left ( ) top = face.top ( ) right = face.right ( ) bottom = face.bottom ( ) img = img[top:bottom, left:right] # img=io.imread('image/now.png') img = transform.resize ( img, (w, h, c) ) res = sess.run ( predict, feed_dict=&#123;x: [img]&#125; ) print ( ID[res[0]] ) # 退出 实验结果分析最终的训练的结果： 根据我自己的数据化的数据图： 识别过程：（拿我自己的照片做的测试）：]]></content>
      <categories>
        <category>Python</category>
        <category>人脸识别</category>
      </categories>
      <tags>
        <tag>人脸识别</tag>
      </tags>
  </entry>
</search>
