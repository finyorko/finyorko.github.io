<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序算法</title>
      <link href="/sort.html"/>
      <url>/sort.html</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span> <span class="comment">//交換兩個變數</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//走訪未排序的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])    <span class="comment">//找到目前最小值</span></span><br><span class="line">                min = j;    <span class="comment">//紀錄最小值</span></span><br><span class="line">           swap(&amp;arr[min], &amp;arr[i]);    <span class="comment">//做交換</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp;j--)</span><br><span class="line">                    arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序使用到了分治的思想, 将一个数组分为两部分, 并分别将两部分排序完成, 而后只用对两个排序好的子序列进行合并即可. 对两个子序列的合并操作也使用相同的策略, 递归的进行. 在进行合并的时候, 需要将原来的数组排序结果保存到另一个数组中, 空间复杂度为$O(n)$. 归并排序时间复杂度为$O(nlog(n))$. 典型应用为求逆序对数. </p><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a = arr;</span><br><span class="line">    <span class="keyword">int</span>* b = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> seg, start;</span><br><span class="line">    <span class="keyword">for</span> (seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);</span><br><span class="line">            <span class="keyword">int</span> k = low;</span><br><span class="line">            <span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>* temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> reg[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line">    <span class="keyword">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">        reg[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start2++];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">        arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reg[len];</span><br><span class="line">    merge_sort_recursive(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Range</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">&#125; Range;</span><br><span class="line"><span class="function">Range <span class="title">new_Range</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    Range r;</span><br><span class="line">    r.start = s;</span><br><span class="line">    r.end = e;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 避免len等于负值引发段错误（Segment Fault）</span></span><br><span class="line">    <span class="comment">// r[]列表,p数量,r[p++]为push,r[--p]为pop且取得元素</span></span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = new_Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = arr[(range.start + range.end) / <span class="number">2</span>]; <span class="comment">//选择中间点为基准点</span></span><br><span class="line">        <span class="keyword">int</span> left = range.start, right = range.end;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid) ++left;   <span class="comment">// 检测基准点左侧是否符合要求</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; mid) --right; <span class="comment">//检测基准点右侧是否符合要求</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(&amp;arr[left],&amp;arr[right]);</span><br><span class="line">                left++;right--;               <span class="comment">//移动指针以继续</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; right) r[p++] = new_Range(range.start, right);</span><br><span class="line">        <span class="keyword">if</span> (range.end &gt; left) r[p++] = new_Range(left, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h4><h5 id="左右指针法"><a href="#左右指针法" class="headerlink" title="左右指针法"></a>左右指针法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = arr[right];</span><br><span class="line">    <span class="keyword">int</span> begin = left, end = right - <span class="number">1</span>;<span class="comment">//左右指针法</span></span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[begin] &lt; mid &amp;&amp; begin &lt; end)</span><br><span class="line">            begin++;</span><br><span class="line">        <span class="keyword">while</span> (arr[end] &gt;= mid &amp;&amp; begin &lt; end)</span><br><span class="line">            end--;</span><br><span class="line">        swap(&amp;arr[begin], &amp;arr[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[begin] &gt;= arr[right])</span><br><span class="line">        swap(&amp;arr[begin], &amp;arr[right]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        begin++;</span><br><span class="line">    <span class="keyword">if</span> (begin)</span><br><span class="line">        quick_sort_recursive(arr, left, begin - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, begin + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    quick_sort(a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="挖洞法"><a href="#挖洞法" class="headerlink" title="挖洞法"></a>挖洞法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(T a[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(end-start &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(end-start == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[start]&gt;a[end])</span><br><span class="line">            swap(a[start], a[end]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> key = a[start], i=start, j=end;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp;  key &lt; a[j])</span><br><span class="line">            j--;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; key &gt; a[i])</span><br><span class="line">            i++;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = key;</span><br><span class="line">    quick_sort(a, start, i<span class="number">-1</span>);</span><br><span class="line">    quick_sort(a, i+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例：找出第k大或者第k小的数"><a href="#例：找出第k大或者第k小的数" class="headerlink" title="例：找出第k大或者第k小的数"></a>例：找出第k大或者第k小的数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">//目前还有错误，还待解决中。。。</span><br><span class="line">//大到小排序1 2 3 4 5 6 7 8 9 10 第五大会出现错误，思路好的时候整理</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//从小到大排序</span><br><span class="line">int partion1(int A[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot = A[low];//用第一个数作为主元</span><br><span class="line">while (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">while (low &lt; high &amp;&amp; A[high] &gt;= pivot)</span><br><span class="line">--high;</span><br><span class="line">A[low] = A[high];</span><br><span class="line">while (low &lt; high&amp;&amp;A[low] &lt;= pivot)</span><br><span class="line">++low;</span><br><span class="line">A[high] = A[low];</span><br><span class="line">&#125;</span><br><span class="line">A[low] = pivot;</span><br><span class="line">return low;</span><br><span class="line">&#125;</span><br><span class="line">//修改大于小于号后，从大到小排序</span><br><span class="line">int partion2(int A[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot = A[low];//用第一个数作为主元</span><br><span class="line">while (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">while (low &lt; high &amp;&amp; A[high] &lt;= pivot)</span><br><span class="line">--high;</span><br><span class="line">A[low] = A[high];</span><br><span class="line">while (low &lt; high&amp;&amp;A[low] &gt;= pivot)</span><br><span class="line">++low;</span><br><span class="line">A[high] = A[low];</span><br><span class="line">&#125;</span><br><span class="line">A[low] = pivot;</span><br><span class="line">return low;</span><br><span class="line">&#125;</span><br><span class="line">//调用从小到大排序的分割法，来找出第K小的数</span><br><span class="line">int find_k_small(int A[], int low, int high, int k)</span><br><span class="line">&#123;</span><br><span class="line">if (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot_pos = partion1(A, low, high);</span><br><span class="line">if (pivot_pos + 1 == k)</span><br><span class="line">return A[pivot_pos];</span><br><span class="line">else if (pivot_pos + 1 &gt; k)</span><br><span class="line">find_k_small(A, low, pivot_pos - 1, k);</span><br><span class="line">else</span><br><span class="line">find_k_small(A, pivot_pos + 1, high, k);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//找出第K大的数</span><br><span class="line">int find_k_big(int A[], int low, int high, int k)</span><br><span class="line">&#123;</span><br><span class="line">if (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot_pos = partion2(A, low, high);</span><br><span class="line">if (pivot_pos + 1 == k)</span><br><span class="line">return A[pivot_pos];</span><br><span class="line">else if (pivot_pos + 1 &gt; k)</span><br><span class="line">return find_k_big(A, low, pivot_pos - 1, k);</span><br><span class="line">else</span><br><span class="line">return find_k_big(A, pivot_pos + 1, high, k);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quick_sort1(int A[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">if (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot_pos = partion1(A, low, high);</span><br><span class="line"></span><br><span class="line">quick_sort1(A, low, pivot_pos - 1);</span><br><span class="line"></span><br><span class="line">quick_sort1(A, pivot_pos + 1, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void quick_sort2(int A[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">if (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot_pos = partion2(A, low, high);</span><br><span class="line"></span><br><span class="line">quick_sort2(A, low, pivot_pos - 1);</span><br><span class="line"></span><br><span class="line">quick_sort2(A, pivot_pos + 1, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cout &lt;&lt; &quot;输入元素个数： &quot;;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int *A = new int[n];</span><br><span class="line">for (int i = 0; i &lt; n; ++i)</span><br><span class="line">cin &gt;&gt; A[i];</span><br><span class="line"></span><br><span class="line">int k;</span><br><span class="line">cout &lt;&lt; &quot;输入要找出第几小的数： &quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; &quot;找出第&quot; &lt;&lt; k &lt;&lt; &quot;小的数:&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int ans = find_k_small(A, 0, n - 1, k);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;排序后的结果：&quot; &lt;&lt; endl;</span><br><span class="line">quick_sort1(A, 0, n - 1);</span><br><span class="line">for (int i = 0; i &lt; n; ++i)</span><br><span class="line">cout &lt;&lt; A[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int k2;</span><br><span class="line">cout &lt;&lt; &quot;输入要找出第几大的数： &quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; k2;</span><br><span class="line">cout &lt;&lt; &quot;找出第&quot; &lt;&lt; k2 &lt;&lt; &quot;大的数:&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ans = find_k_big(A, 0, n - 1, k2);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;排序后的结果：&quot; &lt;&lt; endl;</span><br><span class="line">quick_sort2(A, 0, n - 1);</span><br><span class="line">for (int i = 0; i &lt; n; ++i)</span><br><span class="line">cout &lt;&lt; A[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">delete[] A;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new和malloc内部实现的区别</title>
      <link href="/new&amp;malloc.html"/>
      <url>/new&amp;malloc.html</url>
      
        <content type="html"><![CDATA[<h2 id="new-和-malloc-内部的实现方式有什么区别？"><a href="#new-和-malloc-内部的实现方式有什么区别？" class="headerlink" title="new 和 malloc 内部的实现方式有什么区别？"></a>new 和 malloc 内部的实现方式有什么区别？</h2><p>new 的功能是在堆区新建一个对象，并返回该对象的指针。</p><p>所谓的<strong>【新建对象】</strong>的意思就是，将调用该类的构造函数，因为如果不构造的话，就不能称之为一个对象。</p><p>而 malloc 只是机械的分配一块内存，如果用 mallco 在堆区创建一个对象的话，是不会调用构造函数的。</p><p>严格说来用 malloc 不能算是新建了一个对象，只能说是分配了一块与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，按这个逻辑来，也不存在构造函数什么事。</p><p>同样的，用 delete 去释放一个堆区的对象，会调用该对象的析构函数。</p><p>用 free 去释放一个堆区的对象，不会调用该对象的析构函数。</p><p>做个简单的实验即可明了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TEST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TEST()</span><br><span class="line">    &#123;</span><br><span class="line">        num1 = <span class="number">10</span>;</span><br><span class="line">        num2 = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="string">" "</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用malloc()函数在堆区分配一块内存空间，然后用强制类型转换将该块内存空间</span></span><br><span class="line">    <span class="comment">// 解释为是一个TEST类对象，这不会调用TEST的默认构造函数</span></span><br><span class="line">    TEST * pObj1 = (TEST *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TEST));</span><br><span class="line">    pObj1-&gt;Print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用new在堆区创建一个TEST类的对象，这会调用TEST类的默认构造函数</span></span><br><span class="line">    TEST * pObj2 = <span class="keyword">new</span> TEST;</span><br><span class="line">    pObj2-&gt;Print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">-842150451 -842150451       |</span></span><br><span class="line"><span class="comment">10 20                       |</span></span><br><span class="line"><span class="comment">请按任意键继续. . .         |</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们可以看到pObj1所指的对象中，字段num1与num2都是垃圾值</span></span><br><span class="line"><span class="comment">而pObj2所指的对象中，字段num1与num2显然是经过了构造后的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信防撤回脚本</title>
      <link href="/3.html"/>
      <url>/3.html</url>
      
        <content type="html"><![CDATA[<h4 id="Windows微信防撤回脚本"><a href="#Windows微信防撤回脚本" class="headerlink" title="Windows微信防撤回脚本"></a>Windows微信防撤回脚本</h4><h5 id="测试版本：2-6-7-57-2-6-8-51"><a href="#测试版本：2-6-7-57-2-6-8-51" class="headerlink" title="测试版本：2.6.7.57 ~ 2.6.8.51"></a>测试版本：2.6.7.57 ~ 2.6.8.51</h5><h5 id="下载地址：https-pan-baiduwp-com-s-1UBpRXRyd9uXBeqDbc0DKWg-提取码-6666"><a href="#下载地址：https-pan-baiduwp-com-s-1UBpRXRyd9uXBeqDbc0DKWg-提取码-6666" class="headerlink" title="下载地址：https://pan.baiduwp.com/s/1UBpRXRyd9uXBeqDbc0DKWg  提取码: 6666"></a>下载地址：<a href="https://pan.baiduwp.com/s/1UBpRXRyd9uXBeqDbc0DKWg" target="_blank" rel="noopener">https://pan.baiduwp.com/s/1UBpRXRyd9uXBeqDbc0DKWg</a>  提取码: 6666</h5><h5 id="使用方法：将下载的dll文件，放置在微信的安装目录（WeChat-exe所在目录）下，默认安装目录-（C-Program-Files-x86-Tencent-WeChat），如果在安装微信时，自定义了微信安装位置，请自-行查找。（如果有问题，右下角蓝色聊天框戳我）"><a href="#使用方法：将下载的dll文件，放置在微信的安装目录（WeChat-exe所在目录）下，默认安装目录-（C-Program-Files-x86-Tencent-WeChat），如果在安装微信时，自定义了微信安装位置，请自-行查找。（如果有问题，右下角蓝色聊天框戳我）" class="headerlink" title="使用方法：将下载的dll文件，放置在微信的安装目录（WeChat.exe所在目录）下，默认安装目录      （C:\Program Files(x86)\Tencent\WeChat），如果在安装微信时，自定义了微信安装位置，请自      行查找。（如果有问题，右下角蓝色聊天框戳我）"></a>使用方法：将下载的dll文件，放置在微信的安装目录（WeChat.exe所在目录）下，默认安装目录      （C:\Program Files(x86)\Tencent\WeChat），如果在安装微信时，自定义了微信安装位置，请自      行查找。（如果有问题，右下角蓝色聊天框戳我）</h5><h5 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：<img src="/images/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E%E6%B5%8B%E8%AF%95.png" alt="测试图片"></h5><a id="more"></a><h4 id="组件制作过程"><a href="#组件制作过程" class="headerlink" title="组件制作过程"></a>组件制作过程</h4><h5 id="使用工具：x32dbg调试器"><a href="#使用工具：x32dbg调试器" class="headerlink" title="使用工具：x32dbg调试器"></a>使用工具：x32dbg调试器</h5><h6 id="打开微信，并登录；"><a href="#打开微信，并登录；" class="headerlink" title="打开微信，并登录；"></a>打开微信，并登录；</h6><h6 id="打开x32dbg，文件-附加-选择“微信”，如下图；"><a href="#打开x32dbg，文件-附加-选择“微信”，如下图；" class="headerlink" title="打开x32dbg，文件-附加-选择“微信”，如下图；"></a>打开x32dbg，文件-附加-选择“微信”，如下图；</h6><p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%94%BE%E6%92%A4%E5%9B%9E%E6%AD%A5%E9%AA%A4%E5%9B%BE1.png" alt></p><p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%94%BE%E6%92%A4%E5%9B%9E%E6%AD%A5%E9%AA%A4%E5%9B%BE2.png" alt></p><h6 id="符号-搜索关键词：“win”，选择wechatwin-dll模块，然后双击-跳转至“引用”区域-；"><a href="#符号-搜索关键词：“win”，选择wechatwin-dll模块，然后双击-跳转至“引用”区域-；" class="headerlink" title="符号-搜索关键词：“win”，选择wechatwin.dll模块，然后双击  跳转至“引用”区域  ；"></a>符号-搜索关键词：“win”，选择wechatwin.dll模块，然后双击  跳转至“引用”区域  ；</h6><p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%94%BE%E6%92%A4%E5%9B%9E%E6%AD%A5%E9%AA%A4%E5%9B%BE3.png" alt>      </p><h6 id="右键搜索-当前模块-字符串，输入搜索关键次“revokemsg”，选择-mov-ecx-wechatwin-xxxxxx-字段结果，双击定位至详情"><a href="#右键搜索-当前模块-字符串，输入搜索关键次“revokemsg”，选择-mov-ecx-wechatwin-xxxxxx-字段结果，双击定位至详情" class="headerlink" title="右键搜索-当前模块-字符串，输入搜索关键次“revokemsg”，选择 mov.ecx.wechatwin.xxxxxx  字段结果，双击定位至详情"></a>右键搜索-当前模块-字符串，输入搜索关键次“revokemsg”，选择 mov.ecx.wechatwin.xxxxxx  字段结果，双击定位至详情</h6><p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%94%BE%E6%92%A4%E5%9B%9E%E6%AD%A5%E9%AA%A4%E5%9B%BE4.png" alt></p><p><img src="https://ae01.alicdn.com/kf/Hda1eb807bb424547a48a6f451dab9779k.png" alt></p><h6 id="从定位直至上拉，第一一个je开头行，修改成jmp开头行，点确定"><a href="#从定位直至上拉，第一一个je开头行，修改成jmp开头行，点确定" class="headerlink" title="从定位直至上拉，第一一个je开头行，修改成jmp开头行，点确定"></a>从定位直至上拉，第一一个je开头行，修改成jmp开头行，点确定</h6><p><img src="https://ae01.alicdn.com/kf/H79ad7e6552204a48b774779d003212efh.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 防撤回 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网页下载百度云文件</title>
      <link href="/2.html"/>
      <url>/2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>pandownload网页版正式发布，一款完全免费且支持全平台免登录、免安装的下载工具。</p></blockquote><p><a href="https://www.baiduwp.com" target="_blank" rel="noopener">解析地址1</a></p><p><a href="https://baiduwangpan.com" target="_blank" rel="noopener">解析地址2</a></p><p>在分享链接的baidu后面加上wp可以快速跳转到网页版，例如：<br>  分享链接：  <a href="https://pan.baidu.com/s/1f78tODfx-1g_qTrg4fhVoA" target="_blank" rel="noopener">https://pan.baidu.com/s/1f78tODfx-1g_qTrg4fhVoA</a>  提取码: 6666<br>  网页版链接： <a href="https://pan.baiduwp.com/s/1f78tODfx-1g_qTrg4fhVoA" target="_blank" rel="noopener">https://pan.baiduwp.com/s/1f78tODfx-1g_qTrg4fhVoA</a> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>秘迹搜索</title>
      <link href="/1.html"/>
      <url>/1.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>一个不受追踪的搜索引擎（堪比谷歌）</p></blockquote><p><a href="https://mijisou.com/" target="_blank" rel="noopener">秘迹</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于tensorflow的人脸识别系统</title>
      <link href="/4.html"/>
      <url>/4.html</url>
      
        <content type="html"><![CDATA[<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>ubuntu16.04+Anaconda4.2.0+python3.5+opencv2的环境搭建</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="检验导包问题的代码"><a href="#检验导包问题的代码" class="headerlink" title="检验导包问题的代码"></a>检验导包问题的代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment"># 创建一个常量 op, 产生一个 1x2 矩阵. 这个 op 被作为一个节点</span></span><br><span class="line"><span class="comment"># 加到默认图中.</span></span><br><span class="line"><span class="comment"># 构造器的返回值代表该常量 op 的返回值.</span></span><br><span class="line"><span class="comment">##matrix1 = tf.constant([[3., 3.]])</span></span><br><span class="line"><span class="comment"># 创建另外一个常量 op, 产生一个 2x1 矩阵.</span></span><br><span class="line"><span class="comment">##matrix2 = tf.constant([[2.],[2.]])</span></span><br><span class="line"><span class="comment"># 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.</span></span><br><span class="line"><span class="comment"># 返回值 'product' 代表矩阵乘法的结果.</span></span><br><span class="line"><span class="comment">##product = tf.matmul(matrix1,matrix2)</span></span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, transform</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time    </span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h5 id="将训练集下的图片resize一下，伴随着打开每一个子文件夹，我们要为其设置一个labels，一个文件夹的1000应一个label，共68个abel，这是后面检验acc的唯一指标，即是否能把测试集的照片通过我们的网络输出到指定出口得到正确的label。"><a href="#将训练集下的图片resize一下，伴随着打开每一个子文件夹，我们要为其设置一个labels，一个文件夹的1000应一个label，共68个abel，这是后面检验acc的唯一指标，即是否能把测试集的照片通过我们的网络输出到指定出口得到正确的label。" class="headerlink" title="将训练集下的图片resize一下，伴随着打开每一个子文件夹，我们要为其设置一个labels，一个文件夹的1000应一个label，共68个abel，这是后面检验acc的唯一指标，即是否能把测试集的照片通过我们的网络输出到指定出口得到正确的label。"></a><strong>将训练集下的图片resize一下，伴随着打开每一个子文件夹，我们要为其设置一个labels，一个文件夹的1000应一个label，共68个abel，这是后面检验acc的唯一指标，即是否能把测试集的照片通过我们的网络输出到指定出口得到正确的label。</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">path=<span class="string">''</span></span><br><span class="line"><span class="comment">#将所有的图片resize成100*100</span></span><br><span class="line">w=<span class="number">128</span></span><br><span class="line">h=<span class="number">128</span></span><br><span class="line">c=<span class="number">3</span></span><br><span class="line"><span class="comment">#读取图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_img</span><span class="params">(path)</span>:</span></span><br><span class="line">    cate=[path+<span class="string">'/'</span>+x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(path) <span class="keyword">if</span> os.path.isdir(path+<span class="string">'/'</span>+x)]</span><br><span class="line">    imgs=[]</span><br><span class="line">    labels=[]</span><br><span class="line">    <span class="keyword">for</span> idx,folder <span class="keyword">in</span> enumerate(cate):</span><br><span class="line">        <span class="keyword">for</span> im <span class="keyword">in</span> glob.glob(folder+<span class="string">'/*.png'</span>):</span><br><span class="line">            print(<span class="string">'reading the images:%s'</span>%(im))</span><br><span class="line">            img=io.imread(im)</span><br><span class="line">            img=transform.resize(img,(w,h,c))</span><br><span class="line">            imgs.append(img)</span><br><span class="line">            labels.append(idx)</span><br><span class="line">    <span class="keyword">return</span> np.asarray(imgs,np.float32),np.asarray(labels,np.int32) </span><br><span class="line">data,label=read_img(path)</span><br><span class="line"><span class="comment"># 将所有数据分为训练集和验证集</span></span><br><span class="line">ratio = <span class="number">0.95</span><span class="comment">#训练集占比</span></span><br><span class="line">s = np.int ( num_example * ratio )</span><br><span class="line">x_train = data[:s]</span><br><span class="line">y_train = label[:s]</span><br><span class="line">x_val = data[s:]</span><br><span class="line">y_val = label[s:]</span><br><span class="line"><span class="comment"># -----------------构建网络----------------------</span></span><br><span class="line"><span class="comment"># 占位符</span></span><br><span class="line">x = tf.placeholder ( tf.float32, shape=[<span class="literal">None</span>, w, h, c], name=<span class="string">'x'</span> )</span><br><span class="line">y_ = tf.placeholder ( tf.int32, shape=[<span class="literal">None</span>, ], name=<span class="string">'y_'</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CNNlayer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 第一个卷积层（128——&gt;64)</span></span><br><span class="line">    conv1 = tf.layers.conv2d (</span><br><span class="line">        inputs=x,</span><br><span class="line">        filters=<span class="number">32</span>,</span><br><span class="line">        kernel_size=[<span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">        padding=<span class="string">"same"</span>,</span><br><span class="line">        activation=tf.nn.relu,        kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ) )</span><br><span class="line">    pool1 = tf.layers.max_pooling2d ( inputs=conv1, pool_size=[<span class="number">2</span>, <span class="number">2</span>], strides=<span class="number">2</span> )</span><br><span class="line">    <span class="comment"># 第二个卷积层(64-&gt;32)</span></span><br><span class="line">    conv2 = tf.layers.conv2d (</span><br><span class="line">        inputs=pool1,</span><br><span class="line">        filters=<span class="number">64</span>,</span><br><span class="line">        kernel_size=[<span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">        padding=<span class="string">"same"</span>,</span><br><span class="line">        activation=tf.nn.relu,        kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ) )</span><br><span class="line">    pool2 = tf.layers.max_pooling2d ( inputs=conv2, pool_size=[<span class="number">2</span>, <span class="number">2</span>], strides=<span class="number">2</span> )</span><br><span class="line">    <span class="comment"># 第三个卷积层(32-&gt;16)</span></span><br><span class="line">    conv3 = tf.layers.conv2d (</span><br><span class="line">        inputs=pool2,</span><br><span class="line">        filters=<span class="number">128</span>,</span><br><span class="line">        kernel_size=[<span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">        padding=<span class="string">"same"</span>,</span><br><span class="line">        activation=tf.nn.relu,        kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ) )</span><br><span class="line">    pool3 = tf.layers.max_pooling2d ( inputs=conv3, pool_size=[<span class="number">2</span>, <span class="number">2</span>], strides=<span class="number">2</span> )</span><br><span class="line">    <span class="comment"># 第四个卷积层(16-&gt;8)</span></span><br><span class="line">    conv4 = tf.layers.conv2d (</span><br><span class="line">        inputs=pool3,</span><br><span class="line">        filters=<span class="number">128</span>,</span><br><span class="line">        kernel_size=[<span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">        padding=<span class="string">"same"</span>,</span><br><span class="line">        activation=tf.nn.relu,      kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ) )</span><br><span class="line">    pool4 = tf.layers.max_pooling2d ( inputs=conv4, pool_size=[<span class="number">2</span>, <span class="number">2</span>], strides=<span class="number">2</span> )</span><br><span class="line">    re1 = tf.reshape ( pool4, [<span class="number">-1</span>, <span class="number">8</span> * <span class="number">8</span> * <span class="number">128</span>] )</span><br><span class="line">    <span class="comment"># 全连接层</span></span><br><span class="line">    dense1 = tf.layers.dense ( inputs=re1,</span><br><span class="line">                               units=<span class="number">1024</span>,</span><br><span class="line">                               activation=tf.nn.relu,                               kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ),                               kernel_regularizer=tf.contrib.layers.l2_regularizer ( <span class="number">0.003</span> ) )</span><br><span class="line">    dense2 = tf.layers.dense ( inputs=dense1,</span><br><span class="line">                              units=<span class="number">512</span>,</span><br><span class="line">                              activation=tf.nn.relu,                               </span><br><span class="line">kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ),                               kernel_regularizer=tf.contrib.layers.l2_regularizer ( <span class="number">0.003</span> ) )</span><br><span class="line">    logits = tf.layers.dense ( inputs=dense2,</span><br><span class="line">                               units=<span class="number">68</span>,</span><br><span class="line">                               activation=<span class="literal">None</span>,                               kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ),</span><br><span class="line">                               kernel_regularizer=tf.contrib.layers.l2_regularizer ( <span class="number">0.003</span> ) )</span><br><span class="line">    <span class="keyword">return</span> logits</span><br><span class="line"><span class="comment"># ----------网络结束---------------------------</span></span><br><span class="line"><span class="comment"># 定义一个函数，按批次取数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minibatches</span><span class="params">(inputs=None, targets=None, batch_size=None, shuffle=False)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> len ( inputs ) == len ( targets )</span><br><span class="line">    <span class="keyword">if</span> shuffle:</span><br><span class="line">        indices = np.arange ( len ( inputs ) )</span><br><span class="line">        np.random.shuffle ( indices )</span><br><span class="line">    <span class="keyword">for</span> start_idx <span class="keyword">in</span> range ( <span class="number">0</span>, len ( inputs ) - batch_size + <span class="number">1</span>, batch_size ):</span><br><span class="line">        <span class="keyword">if</span> shuffle:</span><br><span class="line">            excerpt = indices[start_idx:start_idx + batch_size]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            excerpt = slice ( start_idx, start_idx + batch_size )</span><br><span class="line">        <span class="keyword">yield</span> inputs[excerpt], targets[excerpt]</span><br><span class="line"><span class="comment"># 训练和测试数据，可将n_epoch设置更大一些</span></span><br><span class="line">saver = tf.train.Saver ( max_to_keep=<span class="number">3</span> )</span><br><span class="line">max_acc = <span class="number">0</span></span><br><span class="line">f = open ( <span class="string">'ckpt1/acc.txt'</span>, <span class="string">'w'</span> )</span><br><span class="line">n_epoch = <span class="number">10</span></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">sess = tf.InteractiveSession ( )</span><br><span class="line">sess.run ( tf.global_variables_initializer ( ) )</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range ( n_epoch ):</span><br><span class="line">    start_time = time.time ( )</span><br><span class="line">    <span class="comment"># training</span></span><br><span class="line">    train_loss, train_acc, n_batch = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_train_a, y_train_a <span class="keyword">in</span> minibatches ( x_train, y_train, batch_size, shuffle=<span class="literal">True</span> ):</span><br><span class="line">        _, err, ac = sess.run ( [train_op, loss, acc], feed_dict=&#123;x: x_train_a, y_: y_train_a&#125; )</span><br><span class="line">        train_loss += err;</span><br><span class="line">        train_acc += ac;</span><br><span class="line">        n_batch += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> ( <span class="string">"   train loss: %f"</span> % (train_loss / n_batch) )</span><br><span class="line">    <span class="keyword">print</span> ( <span class="string">"   train acc: %f"</span> % (train_acc / n_batch) )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># validation</span></span><br><span class="line">    val_loss, val_acc, n_batch = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_val_a, y_val_a <span class="keyword">in</span> minibatches ( x_val, y_val, batch_size, shuffle=<span class="literal">False</span> ):</span><br><span class="line">        err, ac = sess.run ( [loss, acc], feed_dict=&#123;x: x_val_a, y_: y_val_a&#125; )</span><br><span class="line">        val_loss += err;</span><br><span class="line">        val_acc += ac;</span><br><span class="line">        n_batch += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> ( <span class="string">"   validation loss: %f"</span> % (val_loss / n_batch) )</span><br><span class="line">    <span class="keyword">print</span> ( <span class="string">"   validation acc: %f"</span> % (val_acc / n_batch) )</span><br><span class="line">    f.write ( str ( epoch + <span class="number">1</span> ) + <span class="string">', val_acc: '</span> + str ( val_acc ) + <span class="string">'\n'</span> )</span><br><span class="line">    <span class="keyword">if</span> val_acc &gt; max_acc:</span><br><span class="line">        max_acc = val_acc</span><br><span class="line">        saver.save ( sess, <span class="string">'ckpt1/faces.ckpt'</span>, global_step=epoch + <span class="number">1</span> )</span><br><span class="line">f.close ( )</span><br><span class="line"></span><br><span class="line">detector = dlib.get_frontal_face_detector ( )</span><br><span class="line">  <span class="comment"># 获取人脸分类器</span></span><br><span class="line">ID = (<span class="number">1511346</span>,<span class="number">1610731</span>,<span class="number">1610763</span>,<span class="number">1610260</span>,<span class="number">1611407</span>,<span class="number">1611408</span>,      <span class="number">1611409</span>,<span class="number">1611412</span>,<span class="number">1611413</span>,<span class="number">1611415</span>,<span class="number">1611417</span>,<span class="number">1611418</span>,     <span class="number">1611419</span>,<span class="number">1611420</span>,<span class="number">1611421</span>,<span class="number">1611424</span>,<span class="number">1611425</span>,<span class="number">1611426</span>,      <span class="number">1611427</span>,<span class="number">1611430</span>,<span class="number">1611431</span>,<span class="number">1611433</span>,<span class="number">1611434</span>,<span class="number">1611436</span>,      <span class="number">1611437</span>,<span class="number">1611438</span>,<span class="number">1611440</span>,<span class="number">1611444</span>,<span class="number">1611446</span>,<span class="number">1611447</span>,      <span class="number">1611449</span>,<span class="number">1611450</span>,<span class="number">1611451</span>,<span class="number">1511453</span>,<span class="number">1611455</span>,<span class="number">1611458</span>,     <span class="number">1611459</span>,<span class="number">1611460</span>,<span class="number">1611461</span>,<span class="number">1611462</span>,<span class="number">1611470</span>,<span class="number">1611471</span>,    <span class="number">1611472</span>,<span class="number">1611472</span>,<span class="number">1611476</span>,<span class="number">1611478</span>,<span class="number">1611480</span>,<span class="number">1611482</span>,  <span class="number">1611483</span>,<span class="number">1611486</span>,<span class="number">1611487</span>,<span class="number">1611488</span>,<span class="number">1611490</span>,<span class="number">1611491</span>, <span class="number">1611492</span>,<span class="number">1611493</span>,<span class="number">1611494</span>,<span class="number">1613371</span>,<span class="number">1613376</span>,<span class="number">1613378</span>,  <span class="number">1613550</span>,<span class="number">1711459</span> )</span><br><span class="line"><span class="comment">#两个操作是拿到dlib的人脸分类器（相当于dlib的训练代码跑完的结果存下的参数变量结构等东西），然后建个数组当输出和ID的映射</span></span><br><span class="line"><span class="comment">#最终交互检验：</span></span><br><span class="line">user = input ( <span class="string">"图片（G）还是摄像头（V）:"</span> )</span><br><span class="line"><span class="keyword">if</span> user == <span class="string">"G"</span>:</span><br><span class="line">    path = input ( <span class="string">"图片路径名是："</span> )</span><br><span class="line">    img = cv2.imread ( path )</span><br><span class="line">    dets = detector ( img, <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">print</span> ( <span class="string">"Number of faces detected: &#123;&#125;"</span>.format ( len ( dets ) ) )</span><br><span class="line">    <span class="keyword">for</span> index, face <span class="keyword">in</span> enumerate ( dets ):</span><br><span class="line">        <span class="keyword">print</span> (</span><br><span class="line">            <span class="string">'face &#123;&#125;; left &#123;&#125;; top &#123;&#125;; right &#123;&#125;; bottom &#123;&#125;'</span>.format ( index, face.left ( ), face.top ( ), face.right ( ),                                                                    face.bottom ( ) ) )</span><br><span class="line">        left = face.left ( )</span><br><span class="line">        top = face.top ( )</span><br><span class="line">        right = face.right ( )</span><br><span class="line">        bottom = face.bottom ( )</span><br><span class="line">        cv2.rectangle ( img, (left, top), (right, bottom), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">3</span> )</span><br><span class="line">        io.imsave ( <span class="string">'temp.png'</span>, img )</span><br><span class="line">        img1 = io.imread ( <span class="string">'temp.png'</span> )</span><br><span class="line">        img1 = transform.resize ( img1, (w, h, c) )</span><br><span class="line">        cv2.imshow ( <span class="string">'image'</span>, img1 )</span><br><span class="line">        img1 = img[top:bottom, left:right]</span><br><span class="line">        img1 = transform.resize ( img1, (w, h, c) )</span><br><span class="line">        <span class="comment"># cv2.imshow('image1',img)</span></span><br><span class="line">        res = sess.run ( predict, feed_dict=&#123;x: [img1]&#125; )</span><br><span class="line">        <span class="keyword">print</span> ( ID[res[<span class="number">0</span>]] )</span><br><span class="line">    <span class="keyword">if</span> len ( dets ) == <span class="number">0</span>:</span><br><span class="line">        img = transform.resize ( img, (w, h, c) )</span><br><span class="line">        res = sess.run ( predict, feed_dict=&#123;x: [img]&#125; )</span><br><span class="line">        <span class="keyword">print</span> ( ID[res[<span class="number">0</span>]] )</span><br><span class="line">        cv2.waitKey ( <span class="number">0</span> )</span><br><span class="line">        cv2.destroyAllWindows ( )</span><br><span class="line">    cv2.waitKey ( <span class="number">0</span> )</span><br><span class="line">    cv2.destroyAllWindows ( )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 打开摄像头</span></span><br><span class="line">    cap = cv2.VideoCapture ( <span class="number">0</span> )</span><br><span class="line">    <span class="comment"># 视屏封装格式</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, frame = cap.read ( )</span><br><span class="line">        gray = cv2.cvtColor ( frame, cv2.COLOR_BGR2GRAY )</span><br><span class="line">        cv2.imshow ( <span class="string">'frame'</span>, frame )</span><br><span class="line">        <span class="comment"># 抓取图像，s画人脸框，q结束识别</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey ( <span class="number">1</span> ) &amp; <span class="number">0xFF</span> == ord ( <span class="string">'s'</span> ):</span><br><span class="line">            cv2.imwrite ( <span class="string">'now.png'</span>, frame )</span><br><span class="line">            img = cv2.imread ( <span class="string">"now.png"</span> )</span><br><span class="line">            dets = detector ( img, <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">print</span> ( <span class="string">"Number of faces detected: &#123;&#125;"</span>.format ( len ( dets ) ) )</span><br><span class="line">            <span class="keyword">for</span> index, face <span class="keyword">in</span> enumerate ( dets ):</span><br><span class="line">                <span class="keyword">print</span> ( <span class="string">'face &#123;&#125;; left &#123;&#125;; top &#123;&#125;; right &#123;&#125;; bottom &#123;&#125;'</span>.format ( index,                                                                                 face.left ( ), face.top ( ),                                                                                 face.right ( ), face.bottom ( ) ) )</span><br><span class="line">                left = face.left ( )</span><br><span class="line">                top = face.top ( )</span><br><span class="line">                right = face.right ( )</span><br><span class="line">                bottom = face.bottom ( )</span><br><span class="line">                img = img[top:bottom, left:right]</span><br><span class="line">            <span class="comment"># img=io.imread('image/now.png')</span></span><br><span class="line">            img = transform.resize ( img, (w, h, c) )</span><br><span class="line">            res = sess.run ( predict, feed_dict=&#123;x: [img]&#125; )</span><br><span class="line">            <span class="keyword">print</span> ( ID[res[<span class="number">0</span>]] )</span><br><span class="line">        <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><h4 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h4><h5 id="最终的训练的结果："><a href="#最终的训练的结果：" class="headerlink" title="最终的训练的结果："></a>最终的训练的结果：</h5><p><img src="https://pic.superbed.cn/item/5db91f90bd461d945a546d5b.jpg" alt></p><h5 id="根据我自己的数据化的数据图："><a href="#根据我自己的数据化的数据图：" class="headerlink" title="根据我自己的数据化的数据图："></a>根据我自己的数据化的数据图：</h5><p><img src="https://pic.superbed.cn/item/5db91fb3bd461d945a5476e3.jpg" alt></p><h5 id="识别过程：（拿我自己的照片做的测试）："><a href="#识别过程：（拿我自己的照片做的测试）：" class="headerlink" title="识别过程：（拿我自己的照片做的测试）："></a>识别过程：（拿我自己的照片做的测试）：</h5><p><img src="https://i.loli.net/2019/10/30/g7GiJwR8lXVBT5a.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 人脸识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
