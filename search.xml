<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git学习</title>
      <link href="/learngit.html"/>
      <url>/learngit.html</url>
      
        <content type="html"><![CDATA[<h3 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h3><h4 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h4><h5 id="在liunx上安装Git"><a href="#在liunx上安装Git" class="headerlink" title="在liunx上安装Git"></a>在liunx上安装Git</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><ol><li>创建空目录 <code>mkdir dir_name</code></li><li>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库 </li></ol><h4 id="时光穿梭机"><a href="#时光穿梭机" class="headerlink" title="时光穿梭机"></a>时光穿梭机</h4><h5 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">$ git log --pretty=oneline</span><br></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志 </p><p> 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code></p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">$ git reset --hard commit_id //知道commit_id的情况</span><br></pre></td></tr></table></figure><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到某个版本后，又想回到后面修改的版本，Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h5 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h5><ol><li><p>工作区就是在电脑里能看到的目录</p></li><li><p>版本库</p><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p></li></ol><p><img src="https://pic.superbed.cn/item/5dd4e29a8e0e2e3ee94ccc0e.jpg" alt></p><p>把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><h5 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h5><p>提交后，用<code>git diff HEAD -- file_name</code>命令可以查看工作区和版本库里面最新版本的区别。</p><p>每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中 </p><h5 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h5><p>撤销工作区的修改： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- file_name //在add之前</span><br></pre></td></tr></table></figure><p>撤销暂存区修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD file_name  //已经add ，执行会放回工作区</span><br><span class="line">$ git checkout -- file_name</span><br></pre></td></tr></table></figure><h6 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h6><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file_name</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD file_name</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，就用版本回退的知识，不过前提是没有推送到远程库。</p><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ rm file_name</span><br><span class="line">$ git rm file_name</span><br><span class="line">$ git commit -m &quot;info&quot;</span><br></pre></td></tr></table></figure><p>还有一种情况是工作区中的文件被误删(<code>rm file_name</code>), 此时我们可以使用版本库中的文件对其进行恢复操作. 即使用<code>git checkout -- file_name</code> 即使用版本库中的文件(暂存区或版本库)对工作区文件恢复.</p><p>如果是使用<code>git rm file_name</code> 对文件删除, 则是先删除工作区文件, 在进行了一次add, 即将暂存区的文件也删除了, 此时如果想要恢复则应该先恢复暂存区的文件<code>git reset HEAD file_name</code>, 再恢复工作区文件 <code>git checkout -- file_name</code></p><p>这里删除文件而后上传到远程仓库, 远程仓库中文件也会被删除.</p><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><h5 id="创建ssh"><a href="#创建ssh" class="headerlink" title="创建ssh"></a>创建ssh</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。 登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容</p><h5 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:finyorko/learngit.git</span><br></pre></td></tr></table></figure><h5 id="将代码传到GitHub"><a href="#将代码传到GitHub" class="headerlink" title="将代码传到GitHub"></a>将代码传到GitHub</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p>第一次需要<code>-u</code>, Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>从现在起，只要本地作了提交，就可以通过命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><h5 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;name&gt;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch &lt;name&gt;// 创建分支</span><br><span class="line">$ git checkout &lt;name&gt; // 切换分支</span><br></pre></td></tr></table></figure><p>可以使用<code>git branch</code>显示工作目录下存在的分支以及当前所处分支 </p><p>切换分支也可以用 <code>git switch &lt;name&gt;</code></p><p>我们在dev中工作完成就可以将分支<name>合并到master</name></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;name&gt;</span><br></pre></td></tr></table></figure><p>删除分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d &lt;name&gt;</span><br><span class="line"></span><br><span class="line">$ git branch -D &lt;name&gt; 强行删除</span><br></pre></td></tr></table></figure><p>查看分支的合并情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">包括分支合并图、一行显示、提交校验码缩略显示</span><br></pre></td></tr></table></figure><h5 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h5><p>当我们在合并后, 常常会将分支删除, 此时我们就不知道了分支合并前的信息, 为了保留合并前信息, 我们在合并时要关闭<code>Fast forward</code> 使用如下命令合并即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br></pre></td></tr></table></figure><p>后面的-m是该命令调用了commit命令, 生成了一个存储合并前的文件.</p><h5 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h5><p>之前的合并均是在一个分支上没有变换, 另一个分支上发生了变换, 此时的合并规则较为简单, 当两个文件均发生了改变时, 会引起合并冲突.</p><p>此时在主分支合并时, git会告诉我们存在冲突, 而对应的工作区文件也会被git更改, 显示出冲突的位置, Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>(当前工作区冲突内容)，<code>=======</code>(分割)，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>(要合并的部分冲突内容)标记出不同分支的内容. 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><p>此时我们需要对该文件进行手动修复，删除分支， 然后再提交一遍即可. 提交就相当于告诉git修复完成， 对当前分支进行更新，修复主分支不会影响另一个分支，切换会另一个分支，其内容依旧是其更改之后的样子。</p><h5 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h5><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交， 并不是你不想提交，而是工作只进行到一半，还没法提交 </p><h6 id="存储工作区"><a href="#存储工作区" class="headerlink" title="存储工作区"></a>存储工作区</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git checkout -b issue-101</span><br></pre></td></tr></table></figure><p>现在修复bug，修复完提交： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br></pre></td></tr></table></figure><p>太棒了，bug修复完了！现在，是时候接着回到<code>dev</code>分支干活了！ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br></pre></td></tr></table></figure><h6 id="恢复工作区"><a href="#恢复工作区" class="headerlink" title="恢复工作区"></a>恢复工作区</h6><p>刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><p>恢复方法有两个:</p><ul><li>用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除 </li><li>用<code>git stash pop</code>，恢复的同时把stash内容也删了 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br><span class="line">$ git stash drop stash@&#123;n&#125;</span><br></pre></td></tr></table></figure><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>那怎么在dev分支上修复同样的bug？</p><p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。 </p><h5 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h5><h6 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h6><p>要查看远程库的信息，用<code>git remote</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h6 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h6><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><p><code>master</code>分支是主分支，因此要时刻与远程同步；</p></li><li><p><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p></li><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ </p></li></ul><h6 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h6><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone ...</span><br></pre></td></tr></table></figure><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p> <code>dev</code>为克隆下来分支名称, <code>origin/dev</code>表示从远程克隆哪个分支. </p><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add file_name</span><br><span class="line">git commit -m &quot;add file_name&quot;</span><br><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送 ，会推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br></pre></td></tr></table></figure><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/dev dev</span><br><span class="line">Branch &apos;dev&apos; set up to track remote branch &apos;dev&apos; from &apos;origin&apos;.</span><br></pre></td></tr></table></figure><p> 而后在使用 <code>git pull</code>. 此时可能会发生合并冲突,在本地进行更改,而后提交即可. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure><h6 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h6><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>  推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to  origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h6 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h6><ul><li>查看远程库信息，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li></ul><h5 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase</span><br></pre></td></tr></table></figure><p>rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。 </p><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul><h5 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h5><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h6 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h6><p>打标签首先切换到需要打标签的分支上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &apos;master&apos;</span><br></pre></td></tr></table></figure><p> 然后，敲命令<code>git tag</code>就可以打一个新标签： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag tag_name commt-id</span><br></pre></td></tr></table></figure><p>在创建时添加说明文字:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a tag_name -m &quot;info&quot; commit_id</span><br></pre></td></tr></table></figure><p>其中用<code>-a</code>指定标签名，<code>-m</code>指定说明文字。</p><p>查看所有标签（ 标签不是按时间顺序列出，而是按字母排序的 ）:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure><p>查看标签信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git show tag_name</span><br></pre></td></tr></table></figure><p>会展示对应提交的相关信息.</p><h6 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h6><p>删除:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d tag_name</span><br></pre></td></tr></table></figure><p>推送标签到远程库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin tag_name</span><br></pre></td></tr></table></figure><p>一次性推送全部尚未推送到远程的本地标签：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure><p>删除远程标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">先在本地删除.</span><br><span class="line">$ git tag -d tag_name</span><br><span class="line">再删除远程仓库</span><br><span class="line">$ git push origin :refs/tags/tag_name</span><br></pre></td></tr></table></figure><h4 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h4><h5 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h5><p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览 </p><p> [忽略文件][<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> ]</p><p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了，如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -f file_name</span><br></pre></td></tr></table></figure><p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git check-ignore -v file_name</span><br></pre></td></tr></table></figure><h5 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h5><p>在输入命令时, 总会由于名字太长而不方便, 这时我们可以为命令配置一个简单的别名,此时我们只用输入简单的指令就能够实现一长串指令的操作岂不美滋滋. 语法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.your_command origin_command</span><br></pre></td></tr></table></figure><p> <code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用， 如果不加，那只针对当前的仓库起作用 。</p><p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中</p><p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中 </p>]]></content>
      
      
      <categories>
          
          <category> -Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go语言学习笔记</title>
      <link href="/go_learning.html"/>
      <url>/go_learning.html</url>
      
        <content type="html"><![CDATA[<h3 id="Go语言学习笔记"><a href="#Go语言学习笔记" class="headerlink" title="Go语言学习笔记"></a>Go语言学习笔记</h3><h4 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h4><p>hello.go ，（Go 语言源文件的扩展是 .go），代码如下： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 要执行 Go 语言代码可以使用 <code>go run</code>命令。 </p><p> 执行以上代码输出: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run hello.go </span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><p> 此外我们还可以使用 <code>go build</code>命令来生成二进制文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go build hello.go </span><br><span class="line">$ ls</span><br><span class="line">hello    hello.go</span><br><span class="line">$ ./hello </span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h4 id="Go语言结构"><a href="#Go语言结构" class="headerlink" title="Go语言结构"></a>Go语言结构</h4><h5 id="GO-Hello-World-实例"><a href="#GO-Hello-World-实例" class="headerlink" title="GO Hello World 实例"></a>GO Hello World 实例</h5><p> Go 语言的基础组成有以下几个部分： </p><ul><li>包声明</li><li>引用包</li><li>函数</li><li>变量</li><li>语句&amp;表达式</li><li>注释</li></ul><p>通过实例来解释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 这是我的第一个简单的程序 */</span></span><br><span class="line">   fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>第一行代码 <code>package main</code>定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</li><li>下一行 <code>import &quot;fmt&quot;</code>告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。</li><li>下一行 <code>func main()</code> 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</li><li>下一行<code>/*...*/</code>是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</li><li>下一行<code>fmt.Println(...)</code>可以将字符串输出到控制台，并在最后自动增加换行字符 \n。<br>使用 <code>fmt.Print(&quot;hello, world\n&quot;)</code>可以得到相同的结果。<br>Print 和 Println 这两个函数也支持使用变量，如：<code>fmt.Println(arr)</code>。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</li><li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：<code>Group1</code>，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，如<code>group</code>，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</li></ol><h5 id="执行Go程序"><a href="#执行Go程序" class="headerlink" title="执行Go程序"></a>执行Go程序</h5><ul><li>输入命令 <em>go run hello.go</em> 并按回车执行代码 </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> run hello.<span class="keyword">go</span></span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><ul><li>我们还可以使用 <strong>go build</strong> 命令来生成二进制文件： </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">go</span> build hello.<span class="keyword">go</span> </span><br><span class="line">$ ls</span><br><span class="line">hello    hello.<span class="keyword">go</span></span><br><span class="line">$ ./hello </span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>需要注意的是<code>{</code>不能单独放在一行，所以以下代码在运行时会产生错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>  <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// 错误，&#123; 不能在单独的行上</span></span><br><span class="line">  fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h5><ol><li><p>当前的调试部分可以使用 <strong>go run filename.go</strong> 来执行。 </p><p>可以生成一个 <strong>build.sh</strong> 脚本，用于在指定位置产生已编译好的 可执文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">CURRENT_DIR=`<span class="built_in">pwd</span>`</span><br><span class="line">OLD_GO_PATH=<span class="string">"<span class="variable">$GOPATH</span>"</span>  <span class="comment">#例如: /usr/local/go</span></span><br><span class="line">OLD_GO_BIN=<span class="string">"<span class="variable">$GOBIN</span>"</span>    <span class="comment">#例如: /usr/local/go/bin</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="string">"<span class="variable">$CURRENT_DIR</span>"</span> </span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="string">"<span class="variable">$CURRENT_DIR</span>/bin"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定并整理当前的源码路径</span></span><br><span class="line">gofmt -w src</span><br><span class="line"></span><br><span class="line">go install test_hello</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> GOPATH=<span class="string">"<span class="variable">$OLD_GO_PATH</span>"</span></span><br><span class="line"><span class="built_in">export</span> GOBIN=<span class="string">"<span class="variable">$OLD_GO_BIN</span>"</span></span><br></pre></td></tr></table></figure></li><li><p>关于包，根据本地测试得出以下几点：</p></li></ol><ul><li>文件名与包名没有直接关系，不一定要将文件名与包名定成同一个。</li><li>文件夹名与包名没有直接关系，并非需要一致。</li><li>同一个文件夹下的文件只能有一个包名，否则编译报错。</li></ul><p>文件结构:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Test</span><br><span class="line">--helloworld.go</span><br><span class="line"></span><br><span class="line">myMath</span><br><span class="line">--myMath1.go</span><br><span class="line">--myMath2.go</span><br></pre></td></tr></table></figure><p>测试代码: </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helloworld.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"./myMath"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello World!"</span>)</span><br><span class="line">    fmt.Println(mathClass.Add(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">    fmt.Println(mathClass.Sub(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myMath1.go</span></span><br><span class="line"><span class="keyword">package</span> mathClass</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myMath2.go</span></span><br><span class="line"><span class="keyword">package</span> mathClass</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub</span><span class="params">(x,y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Go语言基础语法"><a href="#Go语言基础语法" class="headerlink" title="Go语言基础语法"></a>Go语言基础语法</h4><h5 id="Go标记"><a href="#Go标记" class="headerlink" title="Go标记"></a>Go标记</h5><p>Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Hello, World!"</span>)</span><br></pre></td></tr></table></figure><p> 6 个标记是(每行一个)： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt</span><br><span class="line">.</span><br><span class="line">Println</span><br><span class="line">(</span><br><span class="line">&quot;Hello, World!&quot;</span><br><span class="line"> )</span><br></pre></td></tr></table></figure><h5 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h5><p>在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。</p><p>如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。</p><p>以下为两个语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">"Hello, World!"</span>)</span><br><span class="line">fmt.Println(<span class="string">"行分隔符，一行一个语句"</span>)</span><br></pre></td></tr></table></figure><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>注释不会被编译，每一个包应该有相关注释。</p><p>单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。</p><p>多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。</p><h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><p>标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A<del>Z和a</del>z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。 </p><p>以下是有效的标识符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mahesh   kumar   abc   move_name   a_123</span><br><span class="line">myname50   _temp   j   a23b9   retVal</span><br></pre></td></tr></table></figure><p>以下是无效的标识符：</p><ul><li>1ab（以数字开头）</li><li>case（Go 语言的关键字）</li><li>a+b（运算符是不允许的）</li></ul><h5 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h5><p> Go 语言的字符串可以通过<code>+</code>实现： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Google"</span> + <span class="string">"Runoob"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">output:</span><br><span class="line">GoogleRunoob</span><br></pre></td></tr></table></figure><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><p>下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table><p>除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：</p><table><thead><tr><th>append</th><th>bool</th><th>byte</th><th>cap</th><th>close</th><th>complex</th><th>complex64</th><th>complex128</th><th>uint16</th></tr></thead><tbody><tr><td>copy</td><td>false</td><td>float32</td><td>float64</td><td>imag</td><td>int</td><td>int8</td><td>int16</td><td>uint32</td></tr><tr><td>int32</td><td>int64</td><td>iota</td><td>len</td><td>make</td><td>new</td><td>nil</td><td>panic</td><td>uint64</td></tr><tr><td>print</td><td>println</td><td>real</td><td>recover</td><td>string</td><td>true</td><td>uint</td><td>uint8</td><td>uintptr</td></tr></tbody></table><h5 id="Go-语言的空格"><a href="#Go-语言的空格" class="headerlink" title="Go 语言的空格"></a>Go 语言的空格</h5><p>Go 语言中变量的声明必须使用空格隔开，如： </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure><h4 id="Go语言数据类型"><a href="#Go语言数据类型" class="headerlink" title="Go语言数据类型"></a>Go语言数据类型</h4><p>在 Go 编程语言中，数据类型用于声明函数和变量。</p><p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p><p>Go 语言按类别有以下几种数据类型：</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>布尔型</strong>  布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td></tr><tr><td align="left">2</td><td align="left"><strong>数字类型</strong> 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td></tr><tr><td align="left">3</td><td align="left"><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td></tr><tr><td align="left">4</td><td align="left"><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）  (b) 数组类型    (c) 结构化类型(struct)     (d) Channel 类型    (e) 函数类型    (f) 切片类型    (g) 接口类型（interface）   (h) Map 类型</td></tr></tbody></table><h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><p>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</p><ul><li>int型</li></ul><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td></tr><tr><td align="left">2</td><td align="left"><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td></tr><tr><td align="left">3</td><td align="left"><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td></tr><tr><td align="left">4</td><td align="left"><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td></tr><tr><td align="left">5</td><td align="left"><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td></tr><tr><td align="left">6</td><td align="left"><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td></tr><tr><td align="left">7</td><td align="left"><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td></tr><tr><td align="left">8</td><td align="left"><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td></tr></tbody></table><ul><li>浮点型：</li></ul><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>float32</strong> IEEE-754 32位浮点型数</td></tr><tr><td align="left">2</td><td align="left"><strong>float64</strong> IEEE-754 64位浮点型数</td></tr><tr><td align="left">3</td><td align="left"><strong>complex64</strong> 32 位实数和虚数</td></tr><tr><td align="left">4</td><td align="left"><strong>complex128</strong> 64 位实数和虚数</td></tr></tbody></table><ul><li>其他数字类型</li></ul><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>byte</strong> 类似 uint8</td></tr><tr><td align="left">2</td><td align="left"><strong>rune</strong> 类似 int32</td></tr><tr><td align="left">3</td><td align="left"><strong>uint</strong> 32 或 64 位</td></tr><tr><td align="left">4</td><td align="left"><strong>int</strong> 与 uint 一样大小</td></tr><tr><td align="left">5</td><td align="left"><strong>uintptr</strong> 无符号整型，用于存放一个指针</td></tr></tbody></table><h5 id="笔记-1"><a href="#笔记-1" class="headerlink" title="笔记"></a>笔记</h5><ul><li>go 1.9版本对于数字类型，无需定义int及float32、float64，系统会自动识别。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">1.5</span></span><br><span class="line">   <span class="keyword">var</span> b =<span class="number">2</span></span><br><span class="line">   fmt.Println(a,b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串去除空格和换行符</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">"fmt"</span>  </span><br><span class="line">    <span class="string">"strings"</span>  </span><br><span class="line">)  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    str := <span class="string">"这里是 www\n.baidu\n.com"</span>  </span><br><span class="line">    fmt.Println(<span class="string">"-------- 原字符串 ----------"</span>)  </span><br><span class="line">    fmt.Println(str)  </span><br><span class="line">    <span class="comment">// 去除空格  </span></span><br><span class="line">    str = strings.Replace(str, <span class="string">" "</span>, <span class="string">""</span>, <span class="number">-1</span>)  </span><br><span class="line">    <span class="comment">// 去除换行符  </span></span><br><span class="line">    str = strings.Replace(str, <span class="string">"\n"</span>, <span class="string">""</span>, <span class="number">-1</span>)  </span><br><span class="line">    fmt.Println(<span class="string">"-------- 去除空格与换行后 ----------"</span>)  </span><br><span class="line">    fmt.Println(str)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-------- 原字符串 ----------</span><br><span class="line">这里是 www</span><br><span class="line">.baidu</span><br><span class="line">.com</span><br><span class="line">-------- 去除空格与换行后 ----------</span><br><span class="line">这里是www.baidu.com</span><br></pre></td></tr></table></figure><h4 id="Go-语言变量"><a href="#Go-语言变量" class="headerlink" title="Go 语言变量"></a>Go 语言变量</h4><p>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。</p><p>声明变量的一般形式是使用 var 关键字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier <span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>可以一次声明多个变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier1, identifier2 <span class="keyword">type</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">string</span> = <span class="string">"Baidu"</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> b, c <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    fmt.Println(b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//output</span></span><br><span class="line">Baidu</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><p>第一种，指定变量类型，如果没有初始化，则变量默认为零值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name v_type</span><br><span class="line">v_name = value</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 没有初始化就为零值*</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">    fmt.Println(b)<span class="comment">//output: 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// bool 零值为 false*</span></span><br><span class="line">  <span class="keyword">var</span> c <span class="keyword">bool</span></span><br><span class="line">    fmt.Println(c)<span class="comment">//output: false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>数值类型（包括complex64/128）为 <strong>0</strong></p></li><li><p>布尔类型为 <strong>false</strong></p></li><li><p>字符串为 <strong>“”</strong>（空字符串）</p></li><li><p>以下几种类型为 <strong>nil</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">a</span> <span class="title">error</span> // <span class="title">error</span> 是接口</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">  <span class="keyword">var</span> f <span class="keyword">float64</span></span><br><span class="line">  <span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">  <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">  fmt.Printf(<span class="string">"%v %v %v %q**\n**"</span>, i, f, b, s)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">0 0 false ""</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>第二种，根据值自行判定变量类型。 </p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name = value</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="literal">true</span></span><br><span class="line">  fmt.Println(d)</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//output: true</span></span><br></pre></td></tr></table></figure><p>第三种，省略 var, 注意 *<em>:=*</em> 左侧如果没有声明新的变量，就产生编译错误，格式：<code>v_name := value</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intVal <span class="keyword">int</span> </span><br><span class="line"></span><br><span class="line">intVal :=<span class="number">1</span> <span class="comment">// 这时候会产生编译错误</span></span><br><span class="line"></span><br><span class="line">intVal,intVal1 := <span class="number">1</span>,<span class="number">2</span> <span class="comment">// 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明</span></span><br></pre></td></tr></table></figure><p> 可以将 <code>var f string = &quot;Baidu&quot;</code>简写为 <code>f := &quot;Baidu&quot;</code></p><h5 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型相同多个变量, 非全局变量</span></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 <span class="keyword">type</span></span><br><span class="line">vname1, vname2, vname3 = v1, v2, v3</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vname1, vname2, vname3 = v1, v2, v3 <span class="comment">// 和 python 很像,不需要显示声明类型，自动推断</span></span><br><span class="line"></span><br><span class="line">vname1, vname2, vname3 := v1, v2, v3 <span class="comment">// 出现在 := 左侧的变量不应该是已经被声明过的，否则会导致编译错误</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    vname1 v_type1</span><br><span class="line">    vname2 v_type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> (  <span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c, d <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> e, f = <span class="number">123</span>, <span class="string">"hello"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这种不带声明格式的只能在函数体中出现</span></span><br><span class="line"><span class="comment">//g, h := 123, "hello"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    g, h := <span class="number">123</span>, <span class="string">"hello"</span></span><br><span class="line">    <span class="built_in">println</span>(x, y, a, b, c, d, e, f, g, h)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">0 0 0 false 1 2 123 hello 123 hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -Go语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Go语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++剑指offer</title>
      <link href="/offer_dir.html"/>
      <url>/offer_dir.html</url>
      
        <content type="html"><![CDATA[<h3 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>从左下角元素往上查找，右边元素是比这个元素大，上边是的元素比这个元素小。于是，target比这个元素小就往上找，比这个元素大就往右找。如果出了边界，则说明二维数组中不存在target元素。 </p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// array是二维数组，这里没做判空操作</span></span><br><span class="line">        <span class="keyword">int</span> rows = <span class="built_in">array</span>.size();</span><br><span class="line">        <span class="keyword">int</span> cols = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> i=rows<span class="number">-1</span>,j=<span class="number">0</span>;<span class="comment">//左下角元素坐标</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; j&lt;cols)&#123;<span class="comment">//使其不超出数组范围</span></span><br><span class="line">            <span class="keyword">if</span>(target&lt;<span class="built_in">array</span>[i][j])</span><br><span class="line">                i--;<span class="comment">//查找的元素较少，往上找</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;<span class="built_in">array</span>[i][j])</span><br><span class="line">                j++;<span class="comment">//查找元素较大，往右找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//找到</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>从前往后记录空格数目，从后往前替换空格</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)&#123;num++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = length <span class="number">-1</span> ; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != <span class="string">' '</span>)&#123;</span><br><span class="line">                    str[i+num*<span class="number">2</span>] = str[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                 str[i+num*<span class="number">2</span>] = <span class="string">'0'</span>;</span><br><span class="line">                 str[i+num*<span class="number">2</span><span class="number">-1</span>] = <span class="string">'2'</span>;</span><br><span class="line">                 str[i+num*<span class="number">2</span><span class="number">-2</span>] = <span class="string">'%'</span>;</span><br><span class="line">                 num--;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>比较简单，直接看代码</p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>方法一： 链表从尾到头输出，利用递归实现，不使用库函数直接printf输出的时候用递归比较好 </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(struct ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            value.insert(value.begin(),head-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempVec = printListFromTailToHead(head-&gt;next);</span><br><span class="line">                <span class="keyword">if</span>(tempVec.size()&gt;<span class="number">0</span>)</span><br><span class="line">                value.insert(value.begin(),tempVec.begin(),tempVec.end());  </span><br><span class="line">            &#125;         </span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>用库函数，每次扫描一个节点，将该结点数据存入vector中，如果该节点有下一节点，将下一节点数据直接插入vector最前面，直至遍历完，或者直接加在最后，最后调用<code>reverse</code> 。[头插vector 效率太低，可以先<code>vector.push_back</code>返回之前翻转vector，<code>std::reverse(begin,end)</code> ]</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(struct ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; value;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            value.insert(value.begin(),head-&gt;val);</span><br><span class="line">            <span class="keyword">while</span>(head-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                value.insert(value.begin(),head-&gt;next-&gt;val);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;         </span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h3><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h4><p>前序加中序序列，分解过程图示如下（王道数据结构P120） </p><p><img src="https://pic.superbed.cn/item/5dc2c7a78e0e2e3ee93d8755.png" alt></p><p><img src="https://pic.superbed.cn/item/5dc2c7f18e0e2e3ee93d9120.png" alt></p><ol><li><p>由先序序列第一个<strong><code>pre[0]</code></strong>在中序序列中找到根节点位置<strong><code>gen</code></strong> </p></li><li><p>以<strong><code>gen</code></strong>为中心遍历 </p></li></ol><ul><li><code>0~gen</code>左子树<ul><li>子中序序列：<strong><code>0~gen-1</code></strong>，放入<strong><code>vin_left[]</code></strong> </li><li>子先序序列：<strong><code>1~gen</code></strong>放入<strong><code>pre_left[]</code></strong>，<strong><code>+1</code></strong>可以看图，因为头部有根节点 </li></ul></li><li><code>gen+1~vinlen</code>为右子树<ul><li>子中序序列：<strong><code>gen+1 ~ vinlen-1</code></strong>放入<strong><code>vin_right[]</code></strong> </li><li>子先序序列：<strong><code>gen+1 ~ vinlen-1</code></strong>放入<strong><code>pre_right[]</code></strong> </li></ul></li></ul><ol start="3"><li>由先序序列<strong><code>pre[0]</code></strong>创建根节点 </li><li>连接左子树，按照左子树子序列递归（<strong><code>pre_left[]</code></strong>和<strong><code>vin_left[]</code></strong>） </li><li>连接右子树，按照右子树子序列递归（<strong><code>pre_right[]</code></strong>和<strong><code>vin_right[]</code></strong>） </li><li>返回根节点</li></ol><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Definition <span class="keyword">for</span> binary tree</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line">TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法一</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">struct TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> inlen = in.size();</span><br><span class="line"><span class="keyword">if</span> (inlen == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_pre, right_pre, left_in, right_in;</span><br><span class="line"><span class="comment">//创建根节点，根节点肯定是前序遍历的第一个数</span></span><br><span class="line">TreeNode* head = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//找到中序遍历根节点所在位置,存放于变量gen中</span></span><br><span class="line"><span class="keyword">int</span> gen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;inlen; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (in[i] == pre[<span class="number">0</span>])</span><br><span class="line">&#123;</span><br><span class="line">gen = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边</span></span><br><span class="line"><span class="comment">//利用上述这点，对二叉树节点进行归并</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;gen; i++)</span><br><span class="line">&#123;</span><br><span class="line">left_in.push_back(in[i]);</span><br><span class="line">left_pre.push_back(pre[i + <span class="number">1</span>]);<span class="comment">//前序第一个为根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = gen + <span class="number">1</span>; i&lt;inlen; i++)</span><br><span class="line">&#123;</span><br><span class="line">right_in.push_back(in[i]);</span><br><span class="line">right_pre.push_back(pre[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//和shell排序的思想类似，取出前序和中序遍历根节点左边和右边的子树</span></span><br><span class="line"><span class="comment">//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span></span><br><span class="line">head-&gt;left = reConstructBinaryTree(left_pre, left_in);</span><br><span class="line">head-&gt;right = reConstructBinaryTree(right_pre, right_in);</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>方法二<strong>（厉害）</strong></li></ul><table><thead><tr><th>$i_{0}$=startIn</th><th>.</th><th>.</th><th>.</th><th>.</th><th>.</th><th>i</th></tr></thead><tbody><tr><td><strong>startPre</strong></td><td>.</td><td>.</td><td>.</td><td>.</td><td>.</td><td>x</td></tr></tbody></table><p>$x=startPre+i-startIn$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">( <span class="keyword">int</span> [] pre, <span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">     TreeNode root=reConstructBinaryTree(pre, <span class="number">0</span> ,pre.length- <span class="number">1</span> ,in, <span class="number">0</span> ,in.length- <span class="number">1</span> );</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">( <span class="keyword">int</span> [] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span> [] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (startPre&gt;endPre||startIn&gt;endIn)</span><br><span class="line">       <span class="keyword">return</span> null ;</span><br><span class="line">     TreeNode root= <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line">     <span class="keyword">for</span> ( <span class="keyword">int</span> i=startIn;i&lt;=endIn;i++)</span><br><span class="line">       <span class="keyword">if</span> (in[i]==pre[startPre])&#123;</span><br><span class="line">         root.left=reConstructBinaryTree(pre,startPre+ <span class="number">1</span> ,startPre+i-startIn,in,startIn,i- <span class="number">1</span> );</span><br><span class="line">         root.right=reConstructBinaryTree(pre,i-startIn+startPre+ <span class="number">1</span> ,endPre,in,i+ <span class="number">1</span> ,endIn);</span><br><span class="line">            <span class="keyword">break</span> ;</span><br><span class="line">       &#125;    </span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h3><h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a>题目分析：</h4><p>入队：将元素进栈A</p><p>出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；如果不为空，栈B直接出栈。</p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack1.push(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">if</span> (stack2.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (!stack1.empty()) </span><br><span class="line">&#123;</span><br><span class="line">a = stack1.top();</span><br><span class="line">stack2.push(a);</span><br><span class="line">stack1.pop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a = stack2.top();</span><br><span class="line">stack2.pop();</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>如果用两个队列实现一个栈的功能?</p><p>解题思路：</p><p>入栈：将元素进队列A </p><p>出栈：判断队列A中元素的个数是否为1，如果等于1，则出队列，否则将队列A中的元素     以此出队列并放入队列B，直到队列A中的元素留下一个，然后队列A出队列，再把     队列B中的元素出队列以此放入队列A中。</p><h3 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h4 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析"></a>题目分析</h4><p>采用二分法解答这个问题：</p><p>mid = low + (high - low)/2 </p><p>需要考虑三种情况： </p><p>(1)array[mid] &gt; array[high]: </p><p>出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。 </p><p> low = mid + 1 </p><p>(2)array[mid] == array[high]: </p><p> 出现这种情况的array类似 [1,0,1,1,1]   或者[1,1,1,0,1]，此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 ， </p><p> high = high - 1 </p><p>(3)array[mid] &lt; array[high]: </p><p>出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左边。因为右边必然都是递增的。 </p><p> high = mid </p><p><strong>注意这里有个坑：如果待查询的范围最后只剩两个数，那么mid</strong> <strong>一定会指向下标靠前的数字</strong>  </p><p>比如 array = [4,6] </p><p>array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ; </p><p>如果high = mid - 1，就会产生错误， 因此high = mid </p><p>但情形(1)中low = mid + 1就不会错误</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span> ; <span class="keyword">int</span> high = <span class="built_in">array</span>.size() - <span class="number">1</span>;   </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;        </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[mid] &gt; <span class="built_in">array</span>[high])&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[mid] == <span class="built_in">array</span>[high])&#123;</span><br><span class="line">                high = high - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>大家都知道斐波那契数列$  \begin{equation} f(x)= \begin{cases} 1&amp; \text{x=1;} \ 1&amp; \text{x=2;} \ 1&amp; \text{$f(n-1)+f(n)$} \end{cases} \end{equation}<br>  $，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p><p>n&lt;=39</p><h4 id="题目分析-3"><a href="#题目分析-3" class="headerlink" title="题目分析"></a>题目分析</h4><p>分别用<code>f</code>和<code>g</code>表示$f(n)$和$f(n+1)$,用循环来实现，最好不要用递归，递归重复计算的部分太多了，花费太大 。</p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = <span class="number">0</span>, g = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">            g += f;</span><br><span class="line">            f = g - f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h4 id="题目分析-4"><a href="#题目分析-4" class="headerlink" title="题目分析"></a>题目分析</h4><p>对于本题,前提只有 一次 1阶或者2阶的跳法。 </p><p>a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);  </p><p>b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)  </p><p>c.由a\b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)  </p><p>d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2  </p><p>e.可以发现最终得出的是一个斐波那契数列：</p><p>$  \begin{equation} f(x)= \begin{cases} 1&amp; \text{x=1;} \ 1&amp; \text{x=2;} \ 1&amp; \text{$f(n-1)+f(n)$} \end{cases} \end{equation}<br>  $</p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>, second = <span class="number">2</span>, third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++) &#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h4 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析-1"></a>题目分析-1</h4><p> 关于本题，前提是n个台阶会有一次n阶的跳法。分析如下: </p><p>f(1) = 1 </p><p>f(2) = f(2-1) + f(2-2)     //f(2-2) 表示2阶一次跳2阶的次数。 </p><p>f(3) = f(3-1) + f(3-2) + f(3-3) </p><p>  … </p><p>f(n) = f(n-1) + f(n-2) + f(n-3) + … + f(n-(n-1)) + f(n-n) </p><p>说明： </p><p>1）这里的f(n) 代表的是n个台阶有一次1,2,…n阶的 跳法数。 </p><p>2）n = 1时，只有1种跳法，f(1) = 1 </p><p>3) n = 2时，会有两个跳得方式，一次1阶或者2阶，这回归到了问题（1） ，</p><p>​    f(2) = f(2-1) + f(2-2) </p><p>4) n = 3时，会有三种跳得方式，1阶、2阶、3阶， 那么就是第一次跳出1阶后面 剩下：f(3-1);第一次跳出2阶，剩下f(3-2)；第一次3阶，那么剩下f(3-3) </p><p>因此结论是f(3) = f(3-1)+f(3-2)+f(3-3) </p><p>5) n = n时，会有n中跳的方式，1阶、2阶…n阶，得出结论： </p><p>​    f(n) = f(n-1)+f(n-2)+…+f(n-(n-1)) + f(n-n) =&gt;  f(0) + f(1) + f(2) + f(3) + … + f(n-1)</p><p>6) 由以上已经是一种结论，但是为了简单，我们可以继续简化： </p><p>   f(n-1) = f(0) + f(1)+f(2)+f(3) + … + f((n-1)-1) =  f(0) + f(1) + f(2) + f(3) + … + f(n-2) </p><p>   f(n) = f(0) + f(1) + f(2) + f(3) + … + f(n-2) +  f(n-1) = f(n-1) + f(n-1) </p><p>   可以得出： </p><p>   f(n) = 2*f(n-1)  </p><p>  7) 得出最终结论,在n阶台阶，一次有1、2、…n阶的跳的方式时，总得跳法为：</p><p>​              $  \begin{equation} f(x)= \begin{cases} 1&amp; \text{n=0;} \ 1&amp; \text{n=1;} \ 2*f(n-1)&amp; \text{$n&gt;=2$} \end{cases} \end{equation}<br>  $</p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现- 1"></a>代码实现- 1</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * JumpFloorII(target - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可以用移位运算符</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Solution &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int jumpFloorII(int number) &#123;</span></span><br><span class="line"><span class="comment">                int a=1; return a&lt;&lt;(number-1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="题目分析-2（概率内容或者基础排列组合？？有点分不清了）"><a href="#题目分析-2（概率内容或者基础排列组合？？有点分不清了）" class="headerlink" title="题目分析-2（概率内容或者基础排列组合？？有点分不清了）"></a>题目分析-2（概率内容或者基础排列组合？？有点分不清了）</h4><p>假设有n（n&gt;=2）个台阶，因为青蛙可以一步跳任意阶，所以第n层台阶一定会被青蛙踩到，剩下的就看第1~n-1层台阶会不会被踩到，每层台阶可以任意选择会不会被踩到，所以有$2^{n-1}$种情况</p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(--number)</span><br><span class="line">        &#123;</span><br><span class="line">            j*=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h3><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><p>我们可以用2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ </p><h4 id="题目分析-5"><a href="#题目分析-5" class="headerlink" title="题目分析"></a>题目分析</h4><p>依旧是斐波那契数列</p><ul><li><p>n&lt;=0时，直接return 1；</p></li><li><p>n=1时，只有一种摆放方法，return 1；</p></li><li><p>n=2时，有两种摆放方法，return 2；</p></li><li><p>n&gt;=2时，分为两步考虑，</p><ul><li>第一次摆放2*1的小矩阵，则 摆放方法总共为f(target - 1) </li></ul><table><thead><tr><th>$\checkmark$</th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>$\checkmark$</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><ul><li>第一次摆放一块1*2的小矩阵，则摆放方法总共为f(target-2)  因为，摆放了一块1*2的小矩阵（用√√表示），对应下方的1*2（用××表示）摆放方法就确定了，所以为f(targte-2) </li></ul><table><thead><tr><th>$\checkmark$</th><th>$\checkmark$</th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>$\times$</td><td>$\times$</td><td></td><td></td><td></td><td></td></tr></tbody></table></li></ul><h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( number &lt; <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> g = <span class="number">1</span>, f = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> ( --number ) &#123;</span><br><span class="line">            f = f + g;</span><br><span class="line">            g = f - g;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> g;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h3><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><h4 id="题目分析-1-1"><a href="#题目分析-1-1" class="headerlink" title="题目分析-1"></a>题目分析-1</h4><p>用1（1自身左移运算，其实后来就不是1了）和n的每位进行位与，来判断1的个数 </p><h4 id="代码实现-1-1"><a href="#代码实现-1-1" class="headerlink" title="代码实现-1"></a>代码实现-1</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (flag != <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>) </span><br><span class="line">count++;</span><br><span class="line">flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="题目分析-2"><a href="#题目分析-2" class="headerlink" title="题目分析-2"></a>题目分析-2</h4><p>使用(n - 1) &amp; n， 把最右边的一个1变成0 </p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现-2"></a>代码实现-2</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">++count;</span><br><span class="line">n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p><h4 id="题目分析-6"><a href="#题目分析-6" class="headerlink" title="题目分析"></a>题目分析</h4><p>简单快速幂</p><p>举例分析：13=1101    $base^{1101}$=$base^{0001}$*$base^{0100}$*$base^{1000}$</p><p>通过&amp;1和&gt;&gt;1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果 </p><h4 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="built_in">abs</span>((<span class="keyword">long</span> <span class="keyword">long</span>)exponent);</span><br><span class="line">      <span class="keyword">double</span> r = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p &amp; <span class="number">1</span>) r *= base;</span><br><span class="line">            base *= base;</span><br><span class="line">            p &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &lt; <span class="number">0</span> ? <span class="number">1</span>/ r : r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/sort.html"/>
      <url>/sort.html</url>
      
        <content type="html"><![CDATA[<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *b)</span> <span class="comment">//交換兩個變數</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selection_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; len - <span class="number">1</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; j++)     <span class="comment">//走訪未排序的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])    <span class="comment">//找到目前最小值</span></span><br><span class="line">                min = j;    <span class="comment">//紀錄最小值</span></span><br><span class="line">           swap(&amp;arr[min], &amp;arr[i]);    <span class="comment">//做交換</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,temp;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j=i;j&gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>]&gt;temp;j--)</span><br><span class="line">                    arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>归并排序使用到了分治的思想, 将一个数组分为两部分, 并分别将两部分排序完成, 而后只用对两个排序好的子序列进行合并即可. 对两个子序列的合并操作也使用相同的策略, 递归的进行. 在进行合并的时候, 需要将原来的数组排序结果保存到另一个数组中, 空间复杂度为$O(n)$. 归并排序时间复杂度为$O(nlog(n))$. 典型应用为求逆序对数. </p><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* a = arr;</span><br><span class="line">    <span class="keyword">int</span>* b = (<span class="keyword">int</span>*) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> seg, start;</span><br><span class="line">    <span class="keyword">for</span> (seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">            <span class="keyword">int</span> low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);</span><br><span class="line">            <span class="keyword">int</span> k = low;</span><br><span class="line">            <span class="keyword">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="keyword">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>* temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> reg[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> len = end - start, mid = (len &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">    <span class="keyword">int</span> start1 = start, end1 = mid;</span><br><span class="line">    <span class="keyword">int</span> start2 = mid + <span class="number">1</span>, end2 = end;</span><br><span class="line">    merge_sort_recursive(arr, reg, start1, end1);</span><br><span class="line">    merge_sort_recursive(arr, reg, start2, end2);</span><br><span class="line">    <span class="keyword">int</span> k = start;</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span><br><span class="line">    <span class="keyword">while</span> (start1 &lt;= end1)</span><br><span class="line">        reg[k++] = arr[start1++];</span><br><span class="line">    <span class="keyword">while</span> (start2 &lt;= end2)</span><br><span class="line">        reg[k++] = arr[start2++];</span><br><span class="line">    <span class="keyword">for</span> (k = start; k &lt;= end; k++)</span><br><span class="line">        arr[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> reg[len];</span><br><span class="line">    merge_sort_recursive(arr, reg, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Range</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, end;</span><br><span class="line">&#125; Range;</span><br><span class="line"><span class="function">Range <span class="title">new_Range</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    Range r;</span><br><span class="line">    r.start = s;</span><br><span class="line">    r.end = e;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">const</span> <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 避免len等于负值引发段错误（Segment Fault）</span></span><br><span class="line">    <span class="comment">// r[]列表,p数量,r[p++]为push,r[--p]为pop且取得元素</span></span><br><span class="line">    Range r[len];</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    r[p++] = new_Range(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        Range range = r[--p];</span><br><span class="line">        <span class="keyword">if</span> (range.start &gt;= range.end)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = arr[(range.start + range.end) / <span class="number">2</span>]; <span class="comment">//选择中间点为基准点</span></span><br><span class="line">        <span class="keyword">int</span> left = range.start, right = range.end;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[left] &lt; mid) ++left;   <span class="comment">// 检测基准点左侧是否符合要求</span></span><br><span class="line">            <span class="keyword">while</span> (arr[right] &gt; mid) --right; <span class="comment">//检测基准点右侧是否符合要求</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(&amp;arr[left],&amp;arr[right]);</span><br><span class="line">                left++;right--;               <span class="comment">//移动指针以继续</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (left &lt;= right);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (range.start &lt; right) r[p++] = new_Range(range.start, right);</span><br><span class="line">        <span class="keyword">if</span> (range.end &gt; left) r[p++] = new_Range(left, range.end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h4><h5 id="左右指针法"><a href="#左右指针法" class="headerlink" title="左右指针法"></a>左右指针法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *x;</span><br><span class="line">    *x = *y;</span><br><span class="line">    *y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort_recursive</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = arr[right];</span><br><span class="line">    <span class="keyword">int</span> begin = left, end = right - <span class="number">1</span>;<span class="comment">//左右指针法</span></span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[begin] &lt; mid &amp;&amp; begin &lt; end)</span><br><span class="line">            begin++;</span><br><span class="line">        <span class="keyword">while</span> (arr[end] &gt;= mid &amp;&amp; begin &lt; end)</span><br><span class="line">            end--;</span><br><span class="line">        swap(&amp;arr[begin], &amp;arr[end]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[begin] &gt;= arr[right])</span><br><span class="line">        swap(&amp;arr[begin], &amp;arr[right]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        begin++;</span><br><span class="line">    <span class="keyword">if</span> (begin)</span><br><span class="line">        quick_sort_recursive(arr, left, begin - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, begin + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>] = &#123; <span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    quick_sort(a, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="挖洞法"><a href="#挖洞法" class="headerlink" title="挖洞法"></a>挖洞法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(T a[], <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(end-start &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(end-start == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[start]&gt;a[end])</span><br><span class="line">            swap(a[start], a[end]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> key = a[start], i=start, j=end;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp;  key &lt; a[j])</span><br><span class="line">            j--;</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; key &gt; a[i])</span><br><span class="line">            i++;</span><br><span class="line">        a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = key;</span><br><span class="line">    quick_sort(a, start, i<span class="number">-1</span>);</span><br><span class="line">    quick_sort(a, i+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="例：找出第k大或者第k小的数"><a href="#例：找出第k大或者第k小的数" class="headerlink" title="例：找出第k大或者第k小的数"></a>例：找出第k大或者第k小的数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">//目前还有错误，还待解决中。。。</span><br><span class="line">//大到小排序1 2 3 4 5 6 7 8 9 10 第五大会出现错误，思路好的时候整理</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">//从小到大排序</span><br><span class="line">int partion1(int A[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot = A[low];//用第一个数作为主元</span><br><span class="line">while (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">while (low &lt; high &amp;&amp; A[high] &gt;= pivot)</span><br><span class="line">--high;</span><br><span class="line">A[low] = A[high];</span><br><span class="line">while (low &lt; high&amp;&amp;A[low] &lt;= pivot)</span><br><span class="line">++low;</span><br><span class="line">A[high] = A[low];</span><br><span class="line">&#125;</span><br><span class="line">A[low] = pivot;</span><br><span class="line">return low;</span><br><span class="line">&#125;</span><br><span class="line">//修改大于小于号后，从大到小排序</span><br><span class="line">int partion2(int A[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot = A[low];//用第一个数作为主元</span><br><span class="line">while (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">while (low &lt; high &amp;&amp; A[high] &lt;= pivot)</span><br><span class="line">--high;</span><br><span class="line">A[low] = A[high];</span><br><span class="line">while (low &lt; high&amp;&amp;A[low] &gt;= pivot)</span><br><span class="line">++low;</span><br><span class="line">A[high] = A[low];</span><br><span class="line">&#125;</span><br><span class="line">A[low] = pivot;</span><br><span class="line">return low;</span><br><span class="line">&#125;</span><br><span class="line">//调用从小到大排序的分割法，来找出第K小的数</span><br><span class="line">int find_k_small(int A[], int low, int high, int k)</span><br><span class="line">&#123;</span><br><span class="line">if (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot_pos = partion1(A, low, high);</span><br><span class="line">if (pivot_pos + 1 == k)</span><br><span class="line">return A[pivot_pos];</span><br><span class="line">else if (pivot_pos + 1 &gt; k)</span><br><span class="line">find_k_small(A, low, pivot_pos - 1, k);</span><br><span class="line">else</span><br><span class="line">find_k_small(A, pivot_pos + 1, high, k);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//找出第K大的数</span><br><span class="line">int find_k_big(int A[], int low, int high, int k)</span><br><span class="line">&#123;</span><br><span class="line">if (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot_pos = partion2(A, low, high);</span><br><span class="line">if (pivot_pos + 1 == k)</span><br><span class="line">return A[pivot_pos];</span><br><span class="line">else if (pivot_pos + 1 &gt; k)</span><br><span class="line">return find_k_big(A, low, pivot_pos - 1, k);</span><br><span class="line">else</span><br><span class="line">return find_k_big(A, pivot_pos + 1, high, k);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">return -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void quick_sort1(int A[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">if (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot_pos = partion1(A, low, high);</span><br><span class="line"></span><br><span class="line">quick_sort1(A, low, pivot_pos - 1);</span><br><span class="line"></span><br><span class="line">quick_sort1(A, pivot_pos + 1, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void quick_sort2(int A[], int low, int high)</span><br><span class="line">&#123;</span><br><span class="line">if (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line">int pivot_pos = partion2(A, low, high);</span><br><span class="line"></span><br><span class="line">quick_sort2(A, low, pivot_pos - 1);</span><br><span class="line"></span><br><span class="line">quick_sort2(A, pivot_pos + 1, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cout &lt;&lt; &quot;输入元素个数： &quot;;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int *A = new int[n];</span><br><span class="line">for (int i = 0; i &lt; n; ++i)</span><br><span class="line">cin &gt;&gt; A[i];</span><br><span class="line"></span><br><span class="line">int k;</span><br><span class="line">cout &lt;&lt; &quot;输入要找出第几小的数： &quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; &quot;找出第&quot; &lt;&lt; k &lt;&lt; &quot;小的数:&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int ans = find_k_small(A, 0, n - 1, k);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;排序后的结果：&quot; &lt;&lt; endl;</span><br><span class="line">quick_sort1(A, 0, n - 1);</span><br><span class="line">for (int i = 0; i &lt; n; ++i)</span><br><span class="line">cout &lt;&lt; A[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">int k2;</span><br><span class="line">cout &lt;&lt; &quot;输入要找出第几大的数： &quot; &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; k2;</span><br><span class="line">cout &lt;&lt; &quot;找出第&quot; &lt;&lt; k2 &lt;&lt; &quot;大的数:&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ans = find_k_big(A, 0, n - 1, k2);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; &quot;排序后的结果：&quot; &lt;&lt; endl;</span><br><span class="line">quick_sort2(A, 0, n - 1);</span><br><span class="line">for (int i = 0; i &lt; n; ++i)</span><br><span class="line">cout &lt;&lt; A[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">delete[] A;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new和malloc内部实现的区别</title>
      <link href="/new&amp;malloc.html"/>
      <url>/new&amp;malloc.html</url>
      
        <content type="html"><![CDATA[<h2 id="new-和-malloc-内部的实现方式有什么区别？"><a href="#new-和-malloc-内部的实现方式有什么区别？" class="headerlink" title="new 和 malloc 内部的实现方式有什么区别？"></a>new 和 malloc 内部的实现方式有什么区别？</h2><p>malloc和new有以下不同:<br>(1) new. delete 是操作符，可以重载，只能在C++中使用。</p><p>(2) malloc. free 是函数，可以覆盖，C、C++中都可以使用。</p><p>(3)new可以调用对象的构造函数，对应的delete调用相应的析构函数。</p><p>(4) malloc仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数</p><p>(5) new. delete 返回的是某种数据类型指针，malloc、 free 返回的是void指针。<br>注意: malloc 申请的内存空间要用free释放，而new申请的内存空间要用delete释放，不要混用。因为两者实现的机理不同。</p><p>解释：new 的功能是在堆区新建一个对象，并返回该对象的指针。</p><p>所谓的<strong>【新建对象】</strong>的意思就是，将调用该类的构造函数，因为如果不构造的话，就不能称之为一个对象。</p><p>而 malloc 只是机械的分配一块内存，如果用 mallco 在堆区创建一个对象的话，是不会调用构造函数的。</p><p>严格说来用 malloc 不能算是新建了一个对象，只能说是分配了一块与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，按这个逻辑来，也不存在构造函数什么事。</p><p>同样的，用 delete 去释放一个堆区的对象，会调用该对象的析构函数。</p><p>用 free 去释放一个堆区的对象，不会调用该对象的析构函数。</p><p>做个简单的实验即可明了:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TEST</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TEST()</span><br><span class="line">    &#123;</span><br><span class="line">        num1 = <span class="number">10</span>;</span><br><span class="line">        num2 = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; <span class="string">" "</span> &lt;&lt; num2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用malloc()函数在堆区分配一块内存空间，然后用强制类型转换将该块内存空间</span></span><br><span class="line">    <span class="comment">// 解释为是一个TEST类对象，这不会调用TEST的默认构造函数</span></span><br><span class="line">    TEST * pObj1 = (TEST *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TEST));</span><br><span class="line">    pObj1-&gt;Print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用new在堆区创建一个TEST类的对象，这会调用TEST类的默认构造函数</span></span><br><span class="line">    TEST * pObj2 = <span class="keyword">new</span> TEST;</span><br><span class="line">    pObj2-&gt;Print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment">-842150451 -842150451       |</span></span><br><span class="line"><span class="comment">10 20                       |</span></span><br><span class="line"><span class="comment">请按任意键继续. . .         |</span></span><br><span class="line"><span class="comment">-----------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">我们可以看到pObj1所指的对象中，字段num1与num2都是垃圾值</span></span><br><span class="line"><span class="comment">而pObj2所指的对象中，字段num1与num2显然是经过了构造后的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>微信防撤回脚本</title>
      <link href="/3.html"/>
      <url>/3.html</url>
      
        <content type="html"><![CDATA[<h4 id="Windows微信防撤回脚本"><a href="#Windows微信防撤回脚本" class="headerlink" title="Windows微信防撤回脚本"></a>Windows微信防撤回脚本</h4><h5 id="测试版本：2-6-7-57-2-6-8-51"><a href="#测试版本：2-6-7-57-2-6-8-51" class="headerlink" title="测试版本：2.6.7.57 ~ 2.6.8.51"></a>测试版本：2.6.7.57 ~ 2.6.8.51</h5><h5 id="下载地址：https-pan-baiduwp-com-s-1UBpRXRyd9uXBeqDbc0DKWg-提取码-6666"><a href="#下载地址：https-pan-baiduwp-com-s-1UBpRXRyd9uXBeqDbc0DKWg-提取码-6666" class="headerlink" title="下载地址：https://pan.baiduwp.com/s/1UBpRXRyd9uXBeqDbc0DKWg  提取码: 6666"></a>下载地址：<a href="https://pan.baiduwp.com/s/1UBpRXRyd9uXBeqDbc0DKWg" target="_blank" rel="noopener">https://pan.baiduwp.com/s/1UBpRXRyd9uXBeqDbc0DKWg</a>  提取码: 6666</h5><h5 id="使用方法：将下载的dll文件，放置在微信的安装目录（WeChat-exe所在目录）下，默认安装目录-（C-Program-Files-x86-Tencent-WeChat），如果在安装微信时，自定义了微信安装位置，请自-行查找。（如果有问题，右下角蓝色聊天框戳我）"><a href="#使用方法：将下载的dll文件，放置在微信的安装目录（WeChat-exe所在目录）下，默认安装目录-（C-Program-Files-x86-Tencent-WeChat），如果在安装微信时，自定义了微信安装位置，请自-行查找。（如果有问题，右下角蓝色聊天框戳我）" class="headerlink" title="使用方法：将下载的dll文件，放置在微信的安装目录（WeChat.exe所在目录）下，默认安装目录      （C:\Program Files(x86)\Tencent\WeChat），如果在安装微信时，自定义了微信安装位置，请自      行查找。（如果有问题，右下角蓝色聊天框戳我）"></a>使用方法：将下载的dll文件，放置在微信的安装目录（WeChat.exe所在目录）下，默认安装目录      （C:\Program Files(x86)\Tencent\WeChat），如果在安装微信时，自定义了微信安装位置，请自      行查找。（如果有问题，右下角蓝色聊天框戳我）</h5><h5 id="测试结果："><a href="#测试结果：" class="headerlink" title="测试结果："></a>测试结果：<img src="/images/%E5%BE%AE%E4%BF%A1%E9%98%B2%E6%92%A4%E5%9B%9E%E6%B5%8B%E8%AF%95.png" alt="测试图片"></h5><a id="more"></a><h4 id="组件制作过程"><a href="#组件制作过程" class="headerlink" title="组件制作过程"></a>组件制作过程</h4><h5 id="使用工具：x32dbg调试器"><a href="#使用工具：x32dbg调试器" class="headerlink" title="使用工具：x32dbg调试器"></a>使用工具：x32dbg调试器</h5><h6 id="打开微信，并登录；"><a href="#打开微信，并登录；" class="headerlink" title="打开微信，并登录；"></a>打开微信，并登录；</h6><h6 id="打开x32dbg，文件-附加-选择“微信”，如下图；"><a href="#打开x32dbg，文件-附加-选择“微信”，如下图；" class="headerlink" title="打开x32dbg，文件-附加-选择“微信”，如下图；"></a>打开x32dbg，文件-附加-选择“微信”，如下图；</h6><p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%94%BE%E6%92%A4%E5%9B%9E%E6%AD%A5%E9%AA%A4%E5%9B%BE1.png" alt></p><p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%94%BE%E6%92%A4%E5%9B%9E%E6%AD%A5%E9%AA%A4%E5%9B%BE2.png" alt></p><h6 id="符号-搜索关键词：“win”，选择wechatwin-dll模块，然后双击-跳转至“引用”区域-；"><a href="#符号-搜索关键词：“win”，选择wechatwin-dll模块，然后双击-跳转至“引用”区域-；" class="headerlink" title="符号-搜索关键词：“win”，选择wechatwin.dll模块，然后双击  跳转至“引用”区域  ；"></a>符号-搜索关键词：“win”，选择wechatwin.dll模块，然后双击  跳转至“引用”区域  ；</h6><p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%94%BE%E6%92%A4%E5%9B%9E%E6%AD%A5%E9%AA%A4%E5%9B%BE3.png" alt>      </p><h6 id="右键搜索-当前模块-字符串，输入搜索关键次“revokemsg”，选择-mov-ecx-wechatwin-xxxxxx-字段结果，双击定位至详情"><a href="#右键搜索-当前模块-字符串，输入搜索关键次“revokemsg”，选择-mov-ecx-wechatwin-xxxxxx-字段结果，双击定位至详情" class="headerlink" title="右键搜索-当前模块-字符串，输入搜索关键次“revokemsg”，选择 mov.ecx.wechatwin.xxxxxx  字段结果，双击定位至详情"></a>右键搜索-当前模块-字符串，输入搜索关键次“revokemsg”，选择 mov.ecx.wechatwin.xxxxxx  字段结果，双击定位至详情</h6><p><img src="/images/%E5%BE%AE%E4%BF%A1%E6%94%BE%E6%92%A4%E5%9B%9E%E6%AD%A5%E9%AA%A4%E5%9B%BE4.png" alt></p><p><img src="https://ae01.alicdn.com/kf/Hda1eb807bb424547a48a6f451dab9779k.png" alt></p><h6 id="从定位直至上拉，第一一个je开头行，修改成jmp开头行，点确定"><a href="#从定位直至上拉，第一一个je开头行，修改成jmp开头行，点确定" class="headerlink" title="从定位直至上拉，第一一个je开头行，修改成jmp开头行，点确定"></a>从定位直至上拉，第一一个je开头行，修改成jmp开头行，点确定</h6><p><img src="https://ae01.alicdn.com/kf/H79ad7e6552204a48b774779d003212efh.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 防撤回 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于tensorflow的人脸识别系统</title>
      <link href="/4.html"/>
      <url>/4.html</url>
      
        <content type="html"><![CDATA[<h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>ubuntu16.04+Anaconda4.2.0+python3.5+opencv2的环境搭建</p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="检验导包问题的代码"><a href="#检验导包问题的代码" class="headerlink" title="检验导包问题的代码"></a>检验导包问题的代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="comment"># 创建一个常量 op, 产生一个 1x2 矩阵. 这个 op 被作为一个节点</span></span><br><span class="line"><span class="comment"># 加到默认图中.</span></span><br><span class="line"><span class="comment"># 构造器的返回值代表该常量 op 的返回值.</span></span><br><span class="line"><span class="comment">##matrix1 = tf.constant([[3., 3.]])</span></span><br><span class="line"><span class="comment"># 创建另外一个常量 op, 产生一个 2x1 矩阵.</span></span><br><span class="line"><span class="comment">##matrix2 = tf.constant([[2.],[2.]])</span></span><br><span class="line"><span class="comment"># 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.</span></span><br><span class="line"><span class="comment"># 返回值 'product' 代表矩阵乘法的结果.</span></span><br><span class="line"><span class="comment">##product = tf.matmul(matrix1,matrix2)</span></span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> io, transform</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time    </span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h5 id="将训练集下的图片resize一下，伴随着打开每一个子文件夹，我们要为其设置一个labels，一个文件夹的1000应一个label，共68个abel，这是后面检验acc的唯一指标，即是否能把测试集的照片通过我们的网络输出到指定出口得到正确的label。"><a href="#将训练集下的图片resize一下，伴随着打开每一个子文件夹，我们要为其设置一个labels，一个文件夹的1000应一个label，共68个abel，这是后面检验acc的唯一指标，即是否能把测试集的照片通过我们的网络输出到指定出口得到正确的label。" class="headerlink" title="将训练集下的图片resize一下，伴随着打开每一个子文件夹，我们要为其设置一个labels，一个文件夹的1000应一个label，共68个abel，这是后面检验acc的唯一指标，即是否能把测试集的照片通过我们的网络输出到指定出口得到正确的label。"></a><strong>将训练集下的图片resize一下，伴随着打开每一个子文件夹，我们要为其设置一个labels，一个文件夹的1000应一个label，共68个abel，这是后面检验acc的唯一指标，即是否能把测试集的照片通过我们的网络输出到指定出口得到正确的label。</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">path=<span class="string">''</span></span><br><span class="line"><span class="comment">#将所有的图片resize成100*100</span></span><br><span class="line">w=<span class="number">128</span></span><br><span class="line">h=<span class="number">128</span></span><br><span class="line">c=<span class="number">3</span></span><br><span class="line"><span class="comment">#读取图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_img</span><span class="params">(path)</span>:</span></span><br><span class="line">    cate=[path+<span class="string">'/'</span>+x <span class="keyword">for</span> x <span class="keyword">in</span> os.listdir(path) <span class="keyword">if</span> os.path.isdir(path+<span class="string">'/'</span>+x)]</span><br><span class="line">    imgs=[]</span><br><span class="line">    labels=[]</span><br><span class="line">    <span class="keyword">for</span> idx,folder <span class="keyword">in</span> enumerate(cate):</span><br><span class="line">        <span class="keyword">for</span> im <span class="keyword">in</span> glob.glob(folder+<span class="string">'/*.png'</span>):</span><br><span class="line">            print(<span class="string">'reading the images:%s'</span>%(im))</span><br><span class="line">            img=io.imread(im)</span><br><span class="line">            img=transform.resize(img,(w,h,c))</span><br><span class="line">            imgs.append(img)</span><br><span class="line">            labels.append(idx)</span><br><span class="line">    <span class="keyword">return</span> np.asarray(imgs,np.float32),np.asarray(labels,np.int32) </span><br><span class="line">data,label=read_img(path)</span><br><span class="line"><span class="comment"># 将所有数据分为训练集和验证集</span></span><br><span class="line">ratio = <span class="number">0.95</span><span class="comment">#训练集占比</span></span><br><span class="line">s = np.int ( num_example * ratio )</span><br><span class="line">x_train = data[:s]</span><br><span class="line">y_train = label[:s]</span><br><span class="line">x_val = data[s:]</span><br><span class="line">y_val = label[s:]</span><br><span class="line"><span class="comment"># -----------------构建网络----------------------</span></span><br><span class="line"><span class="comment"># 占位符</span></span><br><span class="line">x = tf.placeholder ( tf.float32, shape=[<span class="literal">None</span>, w, h, c], name=<span class="string">'x'</span> )</span><br><span class="line">y_ = tf.placeholder ( tf.int32, shape=[<span class="literal">None</span>, ], name=<span class="string">'y_'</span> )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">CNNlayer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 第一个卷积层（128——&gt;64)</span></span><br><span class="line">    conv1 = tf.layers.conv2d (</span><br><span class="line">        inputs=x,</span><br><span class="line">        filters=<span class="number">32</span>,</span><br><span class="line">        kernel_size=[<span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">        padding=<span class="string">"same"</span>,</span><br><span class="line">        activation=tf.nn.relu,        kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ) )</span><br><span class="line">    pool1 = tf.layers.max_pooling2d ( inputs=conv1, pool_size=[<span class="number">2</span>, <span class="number">2</span>], strides=<span class="number">2</span> )</span><br><span class="line">    <span class="comment"># 第二个卷积层(64-&gt;32)</span></span><br><span class="line">    conv2 = tf.layers.conv2d (</span><br><span class="line">        inputs=pool1,</span><br><span class="line">        filters=<span class="number">64</span>,</span><br><span class="line">        kernel_size=[<span class="number">5</span>, <span class="number">5</span>],</span><br><span class="line">        padding=<span class="string">"same"</span>,</span><br><span class="line">        activation=tf.nn.relu,        kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ) )</span><br><span class="line">    pool2 = tf.layers.max_pooling2d ( inputs=conv2, pool_size=[<span class="number">2</span>, <span class="number">2</span>], strides=<span class="number">2</span> )</span><br><span class="line">    <span class="comment"># 第三个卷积层(32-&gt;16)</span></span><br><span class="line">    conv3 = tf.layers.conv2d (</span><br><span class="line">        inputs=pool2,</span><br><span class="line">        filters=<span class="number">128</span>,</span><br><span class="line">        kernel_size=[<span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">        padding=<span class="string">"same"</span>,</span><br><span class="line">        activation=tf.nn.relu,        kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ) )</span><br><span class="line">    pool3 = tf.layers.max_pooling2d ( inputs=conv3, pool_size=[<span class="number">2</span>, <span class="number">2</span>], strides=<span class="number">2</span> )</span><br><span class="line">    <span class="comment"># 第四个卷积层(16-&gt;8)</span></span><br><span class="line">    conv4 = tf.layers.conv2d (</span><br><span class="line">        inputs=pool3,</span><br><span class="line">        filters=<span class="number">128</span>,</span><br><span class="line">        kernel_size=[<span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">        padding=<span class="string">"same"</span>,</span><br><span class="line">        activation=tf.nn.relu,      kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ) )</span><br><span class="line">    pool4 = tf.layers.max_pooling2d ( inputs=conv4, pool_size=[<span class="number">2</span>, <span class="number">2</span>], strides=<span class="number">2</span> )</span><br><span class="line">    re1 = tf.reshape ( pool4, [<span class="number">-1</span>, <span class="number">8</span> * <span class="number">8</span> * <span class="number">128</span>] )</span><br><span class="line">    <span class="comment"># 全连接层</span></span><br><span class="line">    dense1 = tf.layers.dense ( inputs=re1,</span><br><span class="line">                               units=<span class="number">1024</span>,</span><br><span class="line">                               activation=tf.nn.relu,                               kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ),                               kernel_regularizer=tf.contrib.layers.l2_regularizer ( <span class="number">0.003</span> ) )</span><br><span class="line">    dense2 = tf.layers.dense ( inputs=dense1,</span><br><span class="line">                              units=<span class="number">512</span>,</span><br><span class="line">                              activation=tf.nn.relu,                               </span><br><span class="line">kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ),                               kernel_regularizer=tf.contrib.layers.l2_regularizer ( <span class="number">0.003</span> ) )</span><br><span class="line">    logits = tf.layers.dense ( inputs=dense2,</span><br><span class="line">                               units=<span class="number">68</span>,</span><br><span class="line">                               activation=<span class="literal">None</span>,                               kernel_initializer=tf.truncated_normal_initializer ( stddev=<span class="number">0.01</span> ),</span><br><span class="line">                               kernel_regularizer=tf.contrib.layers.l2_regularizer ( <span class="number">0.003</span> ) )</span><br><span class="line">    <span class="keyword">return</span> logits</span><br><span class="line"><span class="comment"># ----------网络结束---------------------------</span></span><br><span class="line"><span class="comment"># 定义一个函数，按批次取数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minibatches</span><span class="params">(inputs=None, targets=None, batch_size=None, shuffle=False)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> len ( inputs ) == len ( targets )</span><br><span class="line">    <span class="keyword">if</span> shuffle:</span><br><span class="line">        indices = np.arange ( len ( inputs ) )</span><br><span class="line">        np.random.shuffle ( indices )</span><br><span class="line">    <span class="keyword">for</span> start_idx <span class="keyword">in</span> range ( <span class="number">0</span>, len ( inputs ) - batch_size + <span class="number">1</span>, batch_size ):</span><br><span class="line">        <span class="keyword">if</span> shuffle:</span><br><span class="line">            excerpt = indices[start_idx:start_idx + batch_size]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            excerpt = slice ( start_idx, start_idx + batch_size )</span><br><span class="line">        <span class="keyword">yield</span> inputs[excerpt], targets[excerpt]</span><br><span class="line"><span class="comment"># 训练和测试数据，可将n_epoch设置更大一些</span></span><br><span class="line">saver = tf.train.Saver ( max_to_keep=<span class="number">3</span> )</span><br><span class="line">max_acc = <span class="number">0</span></span><br><span class="line">f = open ( <span class="string">'ckpt1/acc.txt'</span>, <span class="string">'w'</span> )</span><br><span class="line">n_epoch = <span class="number">10</span></span><br><span class="line">batch_size = <span class="number">64</span></span><br><span class="line">sess = tf.InteractiveSession ( )</span><br><span class="line">sess.run ( tf.global_variables_initializer ( ) )</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range ( n_epoch ):</span><br><span class="line">    start_time = time.time ( )</span><br><span class="line">    <span class="comment"># training</span></span><br><span class="line">    train_loss, train_acc, n_batch = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_train_a, y_train_a <span class="keyword">in</span> minibatches ( x_train, y_train, batch_size, shuffle=<span class="literal">True</span> ):</span><br><span class="line">        _, err, ac = sess.run ( [train_op, loss, acc], feed_dict=&#123;x: x_train_a, y_: y_train_a&#125; )</span><br><span class="line">        train_loss += err;</span><br><span class="line">        train_acc += ac;</span><br><span class="line">        n_batch += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> ( <span class="string">"   train loss: %f"</span> % (train_loss / n_batch) )</span><br><span class="line">    <span class="keyword">print</span> ( <span class="string">"   train acc: %f"</span> % (train_acc / n_batch) )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># validation</span></span><br><span class="line">    val_loss, val_acc, n_batch = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x_val_a, y_val_a <span class="keyword">in</span> minibatches ( x_val, y_val, batch_size, shuffle=<span class="literal">False</span> ):</span><br><span class="line">        err, ac = sess.run ( [loss, acc], feed_dict=&#123;x: x_val_a, y_: y_val_a&#125; )</span><br><span class="line">        val_loss += err;</span><br><span class="line">        val_acc += ac;</span><br><span class="line">        n_batch += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> ( <span class="string">"   validation loss: %f"</span> % (val_loss / n_batch) )</span><br><span class="line">    <span class="keyword">print</span> ( <span class="string">"   validation acc: %f"</span> % (val_acc / n_batch) )</span><br><span class="line">    f.write ( str ( epoch + <span class="number">1</span> ) + <span class="string">', val_acc: '</span> + str ( val_acc ) + <span class="string">'\n'</span> )</span><br><span class="line">    <span class="keyword">if</span> val_acc &gt; max_acc:</span><br><span class="line">        max_acc = val_acc</span><br><span class="line">        saver.save ( sess, <span class="string">'ckpt1/faces.ckpt'</span>, global_step=epoch + <span class="number">1</span> )</span><br><span class="line">f.close ( )</span><br><span class="line"></span><br><span class="line">detector = dlib.get_frontal_face_detector ( )</span><br><span class="line">  <span class="comment"># 获取人脸分类器</span></span><br><span class="line">ID = (<span class="number">1511346</span>,<span class="number">1610731</span>,<span class="number">1610763</span>,<span class="number">1610260</span>,<span class="number">1611407</span>,<span class="number">1611408</span>,      <span class="number">1611409</span>,<span class="number">1611412</span>,<span class="number">1611413</span>,<span class="number">1611415</span>,<span class="number">1611417</span>,<span class="number">1611418</span>,     <span class="number">1611419</span>,<span class="number">1611420</span>,<span class="number">1611421</span>,<span class="number">1611424</span>,<span class="number">1611425</span>,<span class="number">1611426</span>,      <span class="number">1611427</span>,<span class="number">1611430</span>,<span class="number">1611431</span>,<span class="number">1611433</span>,<span class="number">1611434</span>,<span class="number">1611436</span>,      <span class="number">1611437</span>,<span class="number">1611438</span>,<span class="number">1611440</span>,<span class="number">1611444</span>,<span class="number">1611446</span>,<span class="number">1611447</span>,      <span class="number">1611449</span>,<span class="number">1611450</span>,<span class="number">1611451</span>,<span class="number">1511453</span>,<span class="number">1611455</span>,<span class="number">1611458</span>,     <span class="number">1611459</span>,<span class="number">1611460</span>,<span class="number">1611461</span>,<span class="number">1611462</span>,<span class="number">1611470</span>,<span class="number">1611471</span>,    <span class="number">1611472</span>,<span class="number">1611472</span>,<span class="number">1611476</span>,<span class="number">1611478</span>,<span class="number">1611480</span>,<span class="number">1611482</span>,  <span class="number">1611483</span>,<span class="number">1611486</span>,<span class="number">1611487</span>,<span class="number">1611488</span>,<span class="number">1611490</span>,<span class="number">1611491</span>, <span class="number">1611492</span>,<span class="number">1611493</span>,<span class="number">1611494</span>,<span class="number">1613371</span>,<span class="number">1613376</span>,<span class="number">1613378</span>,  <span class="number">1613550</span>,<span class="number">1711459</span> )</span><br><span class="line"><span class="comment">#两个操作是拿到dlib的人脸分类器（相当于dlib的训练代码跑完的结果存下的参数变量结构等东西），然后建个数组当输出和ID的映射</span></span><br><span class="line"><span class="comment">#最终交互检验：</span></span><br><span class="line">user = input ( <span class="string">"图片（G）还是摄像头（V）:"</span> )</span><br><span class="line"><span class="keyword">if</span> user == <span class="string">"G"</span>:</span><br><span class="line">    path = input ( <span class="string">"图片路径名是："</span> )</span><br><span class="line">    img = cv2.imread ( path )</span><br><span class="line">    dets = detector ( img, <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">print</span> ( <span class="string">"Number of faces detected: &#123;&#125;"</span>.format ( len ( dets ) ) )</span><br><span class="line">    <span class="keyword">for</span> index, face <span class="keyword">in</span> enumerate ( dets ):</span><br><span class="line">        <span class="keyword">print</span> (</span><br><span class="line">            <span class="string">'face &#123;&#125;; left &#123;&#125;; top &#123;&#125;; right &#123;&#125;; bottom &#123;&#125;'</span>.format ( index, face.left ( ), face.top ( ), face.right ( ),                                                                    face.bottom ( ) ) )</span><br><span class="line">        left = face.left ( )</span><br><span class="line">        top = face.top ( )</span><br><span class="line">        right = face.right ( )</span><br><span class="line">        bottom = face.bottom ( )</span><br><span class="line">        cv2.rectangle ( img, (left, top), (right, bottom), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">3</span> )</span><br><span class="line">        io.imsave ( <span class="string">'temp.png'</span>, img )</span><br><span class="line">        img1 = io.imread ( <span class="string">'temp.png'</span> )</span><br><span class="line">        img1 = transform.resize ( img1, (w, h, c) )</span><br><span class="line">        cv2.imshow ( <span class="string">'image'</span>, img1 )</span><br><span class="line">        img1 = img[top:bottom, left:right]</span><br><span class="line">        img1 = transform.resize ( img1, (w, h, c) )</span><br><span class="line">        <span class="comment"># cv2.imshow('image1',img)</span></span><br><span class="line">        res = sess.run ( predict, feed_dict=&#123;x: [img1]&#125; )</span><br><span class="line">        <span class="keyword">print</span> ( ID[res[<span class="number">0</span>]] )</span><br><span class="line">    <span class="keyword">if</span> len ( dets ) == <span class="number">0</span>:</span><br><span class="line">        img = transform.resize ( img, (w, h, c) )</span><br><span class="line">        res = sess.run ( predict, feed_dict=&#123;x: [img]&#125; )</span><br><span class="line">        <span class="keyword">print</span> ( ID[res[<span class="number">0</span>]] )</span><br><span class="line">        cv2.waitKey ( <span class="number">0</span> )</span><br><span class="line">        cv2.destroyAllWindows ( )</span><br><span class="line">    cv2.waitKey ( <span class="number">0</span> )</span><br><span class="line">    cv2.destroyAllWindows ( )</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 打开摄像头</span></span><br><span class="line">    cap = cv2.VideoCapture ( <span class="number">0</span> )</span><br><span class="line">    <span class="comment"># 视屏封装格式</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, frame = cap.read ( )</span><br><span class="line">        gray = cv2.cvtColor ( frame, cv2.COLOR_BGR2GRAY )</span><br><span class="line">        cv2.imshow ( <span class="string">'frame'</span>, frame )</span><br><span class="line">        <span class="comment"># 抓取图像，s画人脸框，q结束识别</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey ( <span class="number">1</span> ) &amp; <span class="number">0xFF</span> == ord ( <span class="string">'s'</span> ):</span><br><span class="line">            cv2.imwrite ( <span class="string">'now.png'</span>, frame )</span><br><span class="line">            img = cv2.imread ( <span class="string">"now.png"</span> )</span><br><span class="line">            dets = detector ( img, <span class="number">1</span> )</span><br><span class="line">            <span class="keyword">print</span> ( <span class="string">"Number of faces detected: &#123;&#125;"</span>.format ( len ( dets ) ) )</span><br><span class="line">            <span class="keyword">for</span> index, face <span class="keyword">in</span> enumerate ( dets ):</span><br><span class="line">                <span class="keyword">print</span> ( <span class="string">'face &#123;&#125;; left &#123;&#125;; top &#123;&#125;; right &#123;&#125;; bottom &#123;&#125;'</span>.format ( index,                                                                                 face.left ( ), face.top ( ),                                                                                 face.right ( ), face.bottom ( ) ) )</span><br><span class="line">                left = face.left ( )</span><br><span class="line">                top = face.top ( )</span><br><span class="line">                right = face.right ( )</span><br><span class="line">                bottom = face.bottom ( )</span><br><span class="line">                img = img[top:bottom, left:right]</span><br><span class="line">            <span class="comment"># img=io.imread('image/now.png')</span></span><br><span class="line">            img = transform.resize ( img, (w, h, c) )</span><br><span class="line">            res = sess.run ( predict, feed_dict=&#123;x: [img]&#125; )</span><br><span class="line">            <span class="keyword">print</span> ( ID[res[<span class="number">0</span>]] )</span><br><span class="line">        <span class="comment"># 退出</span></span><br></pre></td></tr></table></figure><h4 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h4><h5 id="最终的训练的结果："><a href="#最终的训练的结果：" class="headerlink" title="最终的训练的结果："></a>最终的训练的结果：</h5><p><img src="https://pic.superbed.cn/item/5db91f90bd461d945a546d5b.jpg" alt></p><h5 id="根据我自己的数据化的数据图："><a href="#根据我自己的数据化的数据图：" class="headerlink" title="根据我自己的数据化的数据图："></a>根据我自己的数据化的数据图：</h5><p><img src="https://pic.superbed.cn/item/5db91fb3bd461d945a5476e3.jpg" alt></p><h5 id="识别过程：（拿我自己的照片做的测试）："><a href="#识别过程：（拿我自己的照片做的测试）：" class="headerlink" title="识别过程：（拿我自己的照片做的测试）："></a>识别过程：（拿我自己的照片做的测试）：</h5><p><img src="https://i.loli.net/2019/10/30/g7GiJwR8lXVBT5a.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> 人脸识别 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
