<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2Fsort.html</url>
    <content type="text"><![CDATA[冒泡排序冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。 12345678910void bubble_sort(int arr[], int len) &#123; int i, j, temp; for (i = 0; i &lt; len - 1; i++) for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125;&#125; 选择排序选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 12345678910111213141516171819void swap(int *a,int *b) //交換兩個變數&#123; int temp = *a; *a = *b; *b = temp;&#125;void selection_sort(int arr[], int len) &#123; int i,j; for (i = 0 ; i &lt; len - 1 ; i++) &#123; int min = i; for (j = i + 1; j &lt; len; j++) //走訪未排序的元素 if (arr[j] &lt; arr[min]) //找到目前最小值 min = j; //紀錄最小值 swap(&amp;arr[min], &amp;arr[i]); //做交換 &#125;&#125; 插入排序插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 123456789void insertion_sort(int arr[], int len)&#123; int i,j,temp; for (i=1;i&lt;len;i++)&#123; temp = arr[i]; for (j=i;j&gt;0 &amp;&amp; arr[j-1]&gt;temp;j--) arr[j] = arr[j-1]; arr[j] = temp; &#125;&#125; 归并排序归并排序使用到了分治的思想, 将一个数组分为两部分, 并分别将两部分排序完成, 而后只用对两个排序好的子序列进行合并即可. 对两个子序列的合并操作也使用相同的策略, 递归的进行. 在进行合并的时候, 需要将原来的数组排序结果保存到另一个数组中, 空间复杂度为$O(n)$. 归并排序时间复杂度为$O(nlog(n))$. 典型应用为求逆序对数. 迭代法1234567891011121314151617181920212223242526272829303132int min(int x, int y) &#123; return x &lt; y ? x : y;&#125;void merge_sort(int arr[], int len) &#123; int* a = arr; int* b = (int*) malloc(len * sizeof(int)); int seg, start; for (seg = 1; seg &lt; len; seg += seg) &#123; for (start = 0; start &lt; len; start += seg + seg) &#123; int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len); int k = low; int start1 = low, end1 = mid; int start2 = mid, end2 = high; while (start1 &lt; end1 &amp;&amp; start2 &lt; end2) b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++]; while (start1 &lt; end1) b[k++] = a[start1++]; while (start2 &lt; end2) b[k++] = a[start2++]; &#125; int* temp = a; a = b; b = temp; &#125; if (a != arr) &#123; int i; for (i = 0; i &lt; len; i++) b[i] = a[i]; b = a; &#125; free(b);&#125; 递归法12345678910111213141516171819202122void merge_sort_recursive(int arr[], int reg[], int start, int end) &#123; if (start &gt;= end) return; int len = end - start, mid = (len &gt;&gt; 1) + start; int start1 = start, end1 = mid; int start2 = mid + 1, end2 = end; merge_sort_recursive(arr, reg, start1, end1); merge_sort_recursive(arr, reg, start2, end2); int k = start; while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++]; while (start1 &lt;= end1) reg[k++] = arr[start1++]; while (start2 &lt;= end2) reg[k++] = arr[start2++]; for (k = start; k &lt;= end; k++) arr[k] = reg[k];&#125;void merge_sort(int arr[], const int len) &#123; int reg[len]; merge_sort_recursive(arr, reg, 0, len - 1);&#125; 快速排序迭代法12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct _Range &#123; int start, end;&#125; Range;Range new_Range(int s, int e) &#123; Range r; r.start = s; r.end = e; return r;&#125;void swap(int *x, int *y) &#123; int t = *x; *x = *y; *y = t;&#125;void quick_sort(int arr[], const int len) &#123; if (len &lt;= 0) return; // 避免len等于负值引发段错误（Segment Fault） // r[]列表,p数量,r[p++]为push,r[--p]为pop且取得元素 Range r[len]; int p = 0; r[p++] = new_Range(0, len - 1); while (p) &#123; Range range = r[--p]; if (range.start &gt;= range.end) continue; int mid = arr[(range.start + range.end) / 2]; //选择中间点为基准点 int left = range.start, right = range.end; do &#123; while (arr[left] &lt; mid) ++left; // 检测基准点左侧是否符合要求 while (arr[right] &gt; mid) --right; //检测基准点右侧是否符合要求 if (left &lt;= right) &#123; swap(&amp;arr[left],&amp;arr[right]); left++;right--; //移动指针以继续 &#125; &#125; while (left &lt;= right); if (range.start &lt; right) r[p++] = new_Range(range.start, right); if (range.end &gt; left) r[p++] = new_Range(left, range.end); &#125;&#125; 递归法左右指针法123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;void swap(int *x, int *y) &#123; int t = *x; *x = *y; *y = t;&#125;void quick_sort_recursive(int arr[], int left, int right) &#123; if (left &gt;= right) return; int mid = arr[right]; int begin = left, end = right - 1;//左右指针法 while (begin &lt; end) &#123; while (arr[begin] &lt; mid &amp;&amp; begin &lt; end) begin++; while (arr[end] &gt;= mid &amp;&amp; begin &lt; end) end--; swap(&amp;arr[begin], &amp;arr[end]); &#125; if (arr[begin] &gt;= arr[right]) swap(&amp;arr[begin], &amp;arr[right]); else begin++; if (begin) quick_sort_recursive(arr, left, begin - 1); quick_sort_recursive(arr, begin + 1, right);&#125;void quick_sort(int arr[], int len) &#123; quick_sort_recursive(arr, 0, len - 1);&#125;int main()&#123; int a[10] = &#123; 8,7,5,10,3,1,2,4,9,6 &#125;; quick_sort(a, 10); for(int i=0;i&lt;10;i++) cout &lt;&lt; a[i]; return 0;&#125; 挖洞法123456789101112131415161718192021222324void quick_sort(T a[], int start, int end)&#123; if(end-start &lt; 1) return; if(end-start == 1) &#123; if(a[start]&gt;a[end]) swap(a[start], a[end]); return; &#125; int key = a[start], i=start, j=end; while (i&lt;j) &#123; while(i&lt;j &amp;&amp; key &lt; a[j]) j--; a[i] = a[j]; while(i&lt;j &amp;&amp; key &gt; a[i]) i++; a[j] = a[i]; &#125; a[i] = key; quick_sort(a, start, i-1); quick_sort(a, i+1, end);&#125; 例：找出第k大或者第k小的数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133//目前还有错误，还待解决中。。。//大到小排序1 2 3 4 5 6 7 8 9 10 第五大会出现错误，思路好的时候整理#include&lt;iostream&gt;using namespace std;//从小到大排序int partion1(int A[], int low, int high)&#123; int pivot = A[low];//用第一个数作为主元 while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &gt;= pivot) --high; A[low] = A[high]; while (low &lt; high&amp;&amp;A[low] &lt;= pivot) ++low; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125;//修改大于小于号后，从大到小排序int partion2(int A[], int low, int high)&#123; int pivot = A[low];//用第一个数作为主元 while (low &lt; high) &#123; while (low &lt; high &amp;&amp; A[high] &lt;= pivot) --high; A[low] = A[high]; while (low &lt; high&amp;&amp;A[low] &gt;= pivot) ++low; A[high] = A[low]; &#125; A[low] = pivot; return low;&#125;//调用从小到大排序的分割法，来找出第K小的数int find_k_small(int A[], int low, int high, int k)&#123; if (low &lt; high) &#123; int pivot_pos = partion1(A, low, high); if (pivot_pos + 1 == k) return A[pivot_pos]; else if (pivot_pos + 1 &gt; k) find_k_small(A, low, pivot_pos - 1, k); else find_k_small(A, pivot_pos + 1, high, k); &#125; else return -1;&#125;//找出第K大的数int find_k_big(int A[], int low, int high, int k)&#123; if (low &lt; high) &#123; int pivot_pos = partion2(A, low, high); if (pivot_pos + 1 == k) return A[pivot_pos]; else if (pivot_pos + 1 &gt; k) return find_k_big(A, low, pivot_pos - 1, k); else return find_k_big(A, pivot_pos + 1, high, k); &#125; else return -1;&#125;void quick_sort1(int A[], int low, int high)&#123; if (low &lt; high) &#123; int pivot_pos = partion1(A, low, high); quick_sort1(A, low, pivot_pos - 1); quick_sort1(A, pivot_pos + 1, high); &#125;&#125;void quick_sort2(int A[], int low, int high)&#123; if (low &lt; high) &#123; int pivot_pos = partion2(A, low, high); quick_sort2(A, low, pivot_pos - 1); quick_sort2(A, pivot_pos + 1, high); &#125;&#125;int main()&#123; int n; cout &lt;&lt; &quot;输入元素个数： &quot;; cin &gt;&gt; n; int *A = new int[n]; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; A[i]; int k; cout &lt;&lt; &quot;输入要找出第几小的数： &quot; &lt;&lt; endl; cin &gt;&gt; k; cout &lt;&lt; &quot;找出第&quot; &lt;&lt; k &lt;&lt; &quot;小的数:&quot; &lt;&lt; endl; int ans = find_k_small(A, 0, n - 1, k); cout &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; &quot;排序后的结果：&quot; &lt;&lt; endl; quick_sort1(A, 0, n - 1); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; A[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; int k2; cout &lt;&lt; &quot;输入要找出第几大的数： &quot; &lt;&lt; endl; cin &gt;&gt; k2; cout &lt;&lt; &quot;找出第&quot; &lt;&lt; k2 &lt;&lt; &quot;大的数:&quot; &lt;&lt; endl; ans = find_k_big(A, 0, n - 1, k2); cout &lt;&lt; ans &lt;&lt; endl; cout &lt;&lt; &quot;排序后的结果：&quot; &lt;&lt; endl; quick_sort2(A, 0, n - 1); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; A[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; delete[] A; return 0;&#125;]]></content>
      <categories>
        <category>C++</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[new和malloc内部实现的区别]]></title>
    <url>%2Fnew%26malloc.html</url>
    <content type="text"><![CDATA[new 和 malloc 内部的实现方式有什么区别？new 的功能是在堆区新建一个对象，并返回该对象的指针。 所谓的【新建对象】的意思就是，将调用该类的构造函数，因为如果不构造的话，就不能称之为一个对象。 而 malloc 只是机械的分配一块内存，如果用 mallco 在堆区创建一个对象的话，是不会调用构造函数的。 严格说来用 malloc 不能算是新建了一个对象，只能说是分配了一块与该类对象匹配的内存而已，然后强行把它解释为【这是一个对象】，按这个逻辑来，也不存在构造函数什么事。 同样的，用 delete 去释放一个堆区的对象，会调用该对象的析构函数。 用 free 去释放一个堆区的对象，不会调用该对象的析构函数。 做个简单的实验即可明了: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;malloc.h&gt;class TEST&#123;private: int num1; int num2;public: TEST() &#123; num1 = 10; num2 = 20; &#125; void Print() &#123; std::cout &lt;&lt; num1 &lt;&lt; " " &lt;&lt; num2 &lt;&lt; std::endl; &#125;&#125;;int main(void)&#123; // 用malloc()函数在堆区分配一块内存空间，然后用强制类型转换将该块内存空间 // 解释为是一个TEST类对象，这不会调用TEST的默认构造函数 TEST * pObj1 = (TEST *)malloc(sizeof(TEST)); pObj1-&gt;Print(); // 用new在堆区创建一个TEST类的对象，这会调用TEST类的默认构造函数 TEST * pObj2 = new TEST; pObj2-&gt;Print(); return 0;&#125;/*运行结果：------------------------------842150451 -842150451 |10 20 |请按任意键继续. . . |-----------------------------我们可以看到pObj1所指的对象中，字段num1与num2都是垃圾值而pObj2所指的对象中，字段num1与num2显然是经过了构造后的值*/]]></content>
  </entry>
  <entry>
    <title><![CDATA[微信防撤回脚本]]></title>
    <url>%2F3.html</url>
    <content type="text"><![CDATA[Windows微信防撤回脚本测试版本：2.6.7.57 ~ 2.6.8.51下载地址：https://pan.baiduwp.com/s/1UBpRXRyd9uXBeqDbc0DKWg 提取码: 6666使用方法：将下载的dll文件，放置在微信的安装目录（WeChat.exe所在目录）下，默认安装目录 （C:\Program Files(x86)\Tencent\WeChat），如果在安装微信时，自定义了微信安装位置，请自 行查找。（如果有问题，右下角蓝色聊天框戳我）测试结果： 组件制作过程使用工具：x32dbg调试器打开微信，并登录；打开x32dbg，文件-附加-选择“微信”，如下图； 符号-搜索关键词：“win”，选择wechatwin.dll模块，然后双击 跳转至“引用”区域 ； 右键搜索-当前模块-字符串，输入搜索关键次“revokemsg”，选择 mov.ecx.wechatwin.xxxxxx 字段结果，双击定位至详情 从定位直至上拉，第一一个je开头行，修改成jmp开头行，点确定]]></content>
      <categories>
        <category>防撤回</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网页下载百度云文件]]></title>
    <url>%2F2.html</url>
    <content type="text"><![CDATA[pandownload网页版正式发布，一款完全免费且支持全平台免登录、免安装的下载工具。 解析地址1 解析地址2 在分享链接的baidu后面加上wp可以快速跳转到网页版，例如： 分享链接： https://pan.baidu.com/s/1f78tODfx-1g_qTrg4fhVoA 提取码: 6666 网页版链接： https://pan.baiduwp.com/s/1f78tODfx-1g_qTrg4fhVoA]]></content>
  </entry>
  <entry>
    <title><![CDATA[秘迹搜索]]></title>
    <url>%2F1.html</url>
    <content type="text"><![CDATA[一个不受追踪的搜索引擎（堪比谷歌） 秘迹]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于tensorflow的人脸识别系统]]></title>
    <url>%2F4.html</url>
    <content type="text"><![CDATA[环境搭建ubuntu16.04+Anaconda4.2.0+python3.5+opencv2的环境搭建 代码分析检验导包问题的代码12345678910111213141516import tensorflow as tf# 创建一个常量 op, 产生一个 1x2 矩阵. 这个 op 被作为一个节点# 加到默认图中.# 构造器的返回值代表该常量 op 的返回值.##matrix1 = tf.constant([[3., 3.]])# 创建另外一个常量 op, 产生一个 2x1 矩阵.##matrix2 = tf.constant([[2.],[2.]])# 创建一个矩阵乘法 matmul op , 把 'matrix1' 和 'matrix2' 作为输入.# 返回值 'product' 代表矩阵乘法的结果.##product = tf.matmul(matrix1,matrix2)from skimage import io, transformimport globimport osimport time import tensorflow as tfimport numpy as np 将训练集下的图片resize一下，伴随着打开每一个子文件夹，我们要为其设置一个labels，一个文件夹的1000应一个label，共68个abel，这是后面检验acc的唯一指标，即是否能把测试集的照片通过我们的网络输出到指定出口得到正确的label。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189path=''#将所有的图片resize成100*100w=128h=128c=3#读取图片def read_img(path): cate=[path+'/'+x for x in os.listdir(path) if os.path.isdir(path+'/'+x)] imgs=[] labels=[] for idx,folder in enumerate(cate): for im in glob.glob(folder+'/*.png'): print('reading the images:%s'%(im)) img=io.imread(im) img=transform.resize(img,(w,h,c)) imgs.append(img) labels.append(idx) return np.asarray(imgs,np.float32),np.asarray(labels,np.int32) data,label=read_img(path)# 将所有数据分为训练集和验证集ratio = 0.95#训练集占比s = np.int ( num_example * ratio )x_train = data[:s]y_train = label[:s]x_val = data[s:]y_val = label[s:]# -----------------构建网络----------------------# 占位符x = tf.placeholder ( tf.float32, shape=[None, w, h, c], name='x' )y_ = tf.placeholder ( tf.int32, shape=[None, ], name='y_' )def CNNlayer(): # 第一个卷积层（128——&gt;64) conv1 = tf.layers.conv2d ( inputs=x, filters=32, kernel_size=[5, 5], padding="same", activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ) ) pool1 = tf.layers.max_pooling2d ( inputs=conv1, pool_size=[2, 2], strides=2 ) # 第二个卷积层(64-&gt;32) conv2 = tf.layers.conv2d ( inputs=pool1, filters=64, kernel_size=[5, 5], padding="same", activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ) ) pool2 = tf.layers.max_pooling2d ( inputs=conv2, pool_size=[2, 2], strides=2 ) # 第三个卷积层(32-&gt;16) conv3 = tf.layers.conv2d ( inputs=pool2, filters=128, kernel_size=[3, 3], padding="same", activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ) ) pool3 = tf.layers.max_pooling2d ( inputs=conv3, pool_size=[2, 2], strides=2 ) # 第四个卷积层(16-&gt;8) conv4 = tf.layers.conv2d ( inputs=pool3, filters=128, kernel_size=[3, 3], padding="same", activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ) ) pool4 = tf.layers.max_pooling2d ( inputs=conv4, pool_size=[2, 2], strides=2 ) re1 = tf.reshape ( pool4, [-1, 8 * 8 * 128] ) # 全连接层 dense1 = tf.layers.dense ( inputs=re1, units=1024, activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ), kernel_regularizer=tf.contrib.layers.l2_regularizer ( 0.003 ) ) dense2 = tf.layers.dense ( inputs=dense1, units=512, activation=tf.nn.relu, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ), kernel_regularizer=tf.contrib.layers.l2_regularizer ( 0.003 ) ) logits = tf.layers.dense ( inputs=dense2, units=68, activation=None, kernel_initializer=tf.truncated_normal_initializer ( stddev=0.01 ), kernel_regularizer=tf.contrib.layers.l2_regularizer ( 0.003 ) ) return logits# ----------网络结束---------------------------# 定义一个函数，按批次取数据def minibatches(inputs=None, targets=None, batch_size=None, shuffle=False): assert len ( inputs ) == len ( targets ) if shuffle: indices = np.arange ( len ( inputs ) ) np.random.shuffle ( indices ) for start_idx in range ( 0, len ( inputs ) - batch_size + 1, batch_size ): if shuffle: excerpt = indices[start_idx:start_idx + batch_size] else: excerpt = slice ( start_idx, start_idx + batch_size ) yield inputs[excerpt], targets[excerpt]# 训练和测试数据，可将n_epoch设置更大一些saver = tf.train.Saver ( max_to_keep=3 )max_acc = 0f = open ( 'ckpt1/acc.txt', 'w' )n_epoch = 10batch_size = 64sess = tf.InteractiveSession ( )sess.run ( tf.global_variables_initializer ( ) )for epoch in range ( n_epoch ): start_time = time.time ( ) # training train_loss, train_acc, n_batch = 0, 0, 0 for x_train_a, y_train_a in minibatches ( x_train, y_train, batch_size, shuffle=True ): _, err, ac = sess.run ( [train_op, loss, acc], feed_dict=&#123;x: x_train_a, y_: y_train_a&#125; ) train_loss += err; train_acc += ac; n_batch += 1 print ( " train loss: %f" % (train_loss / n_batch) ) print ( " train acc: %f" % (train_acc / n_batch) ) # validation val_loss, val_acc, n_batch = 0, 0, 0 for x_val_a, y_val_a in minibatches ( x_val, y_val, batch_size, shuffle=False ): err, ac = sess.run ( [loss, acc], feed_dict=&#123;x: x_val_a, y_: y_val_a&#125; ) val_loss += err; val_acc += ac; n_batch += 1 print ( " validation loss: %f" % (val_loss / n_batch) ) print ( " validation acc: %f" % (val_acc / n_batch) ) f.write ( str ( epoch + 1 ) + ', val_acc: ' + str ( val_acc ) + '\n' ) if val_acc &gt; max_acc: max_acc = val_acc saver.save ( sess, 'ckpt1/faces.ckpt', global_step=epoch + 1 )f.close ( )detector = dlib.get_frontal_face_detector ( ) # 获取人脸分类器ID = (1511346,1610731,1610763,1610260,1611407,1611408, 1611409,1611412,1611413,1611415,1611417,1611418, 1611419,1611420,1611421,1611424,1611425,1611426, 1611427,1611430,1611431,1611433,1611434,1611436, 1611437,1611438,1611440,1611444,1611446,1611447, 1611449,1611450,1611451,1511453,1611455,1611458, 1611459,1611460,1611461,1611462,1611470,1611471, 1611472,1611472,1611476,1611478,1611480,1611482, 1611483,1611486,1611487,1611488,1611490,1611491, 1611492,1611493,1611494,1613371,1613376,1613378, 1613550,1711459 )#两个操作是拿到dlib的人脸分类器（相当于dlib的训练代码跑完的结果存下的参数变量结构等东西），然后建个数组当输出和ID的映射#最终交互检验：user = input ( "图片（G）还是摄像头（V）:" )if user == "G": path = input ( "图片路径名是：" ) img = cv2.imread ( path ) dets = detector ( img, 1 ) print ( "Number of faces detected: &#123;&#125;".format ( len ( dets ) ) ) for index, face in enumerate ( dets ): print ( 'face &#123;&#125;; left &#123;&#125;; top &#123;&#125;; right &#123;&#125;; bottom &#123;&#125;'.format ( index, face.left ( ), face.top ( ), face.right ( ), face.bottom ( ) ) ) left = face.left ( ) top = face.top ( ) right = face.right ( ) bottom = face.bottom ( ) cv2.rectangle ( img, (left, top), (right, bottom), (0, 255, 0), 3 ) io.imsave ( 'temp.png', img ) img1 = io.imread ( 'temp.png' ) img1 = transform.resize ( img1, (w, h, c) ) cv2.imshow ( 'image', img1 ) img1 = img[top:bottom, left:right] img1 = transform.resize ( img1, (w, h, c) ) # cv2.imshow('image1',img) res = sess.run ( predict, feed_dict=&#123;x: [img1]&#125; ) print ( ID[res[0]] ) if len ( dets ) == 0: img = transform.resize ( img, (w, h, c) ) res = sess.run ( predict, feed_dict=&#123;x: [img]&#125; ) print ( ID[res[0]] ) cv2.waitKey ( 0 ) cv2.destroyAllWindows ( ) cv2.waitKey ( 0 ) cv2.destroyAllWindows ( )else: # 打开摄像头 cap = cv2.VideoCapture ( 0 ) # 视屏封装格式 while True: ret, frame = cap.read ( ) gray = cv2.cvtColor ( frame, cv2.COLOR_BGR2GRAY ) cv2.imshow ( 'frame', frame ) # 抓取图像，s画人脸框，q结束识别 if cv2.waitKey ( 1 ) &amp; 0xFF == ord ( 's' ): cv2.imwrite ( 'now.png', frame ) img = cv2.imread ( "now.png" ) dets = detector ( img, 1 ) print ( "Number of faces detected: &#123;&#125;".format ( len ( dets ) ) ) for index, face in enumerate ( dets ): print ( 'face &#123;&#125;; left &#123;&#125;; top &#123;&#125;; right &#123;&#125;; bottom &#123;&#125;'.format ( index, face.left ( ), face.top ( ), face.right ( ), face.bottom ( ) ) ) left = face.left ( ) top = face.top ( ) right = face.right ( ) bottom = face.bottom ( ) img = img[top:bottom, left:right] # img=io.imread('image/now.png') img = transform.resize ( img, (w, h, c) ) res = sess.run ( predict, feed_dict=&#123;x: [img]&#125; ) print ( ID[res[0]] ) # 退出 实验结果分析最终的训练的结果： 根据我自己的数据化的数据图： 识别过程：（拿我自己的照片做的测试）：]]></content>
      <categories>
        <category>Python</category>
        <category>人脸识别</category>
      </categories>
      <tags>
        <tag>人脸识别</tag>
      </tags>
  </entry>
</search>
